<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fution - Week 04</title>
  <!-- tailwindcss CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- bootstrap CDN -->
  <!-- emailjs CDN -->
  <script src="https://cdn.jsdelivr.net/npm/emailjs-com@3/dist/email.min.js"></script>

  <!-- alpine js -->
  <script src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js" defer></script>

  <!-- collapse js -->
  <script defer src="https://cdn.jsdelivr.net/npm/@alpinejs/collapse@3.x.x/dist/cdn.min.js"></script>

  <script>
    emailjs.init("-XBrVlizt4Jkdh9W-"); // Emailjs public key
  </script>
  <link rel="icon" href="logo.png" type="image/x-icon">
  <!-- external stylesheet -->
  <link rel="stylesheet" href="style.css">
  <!-- highlight.js CDN for code syntax highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/github-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/languages/go.min.js"></script>
  <script>hljs.highlightAll();</script>
</head>

<body class="h-dvh overflow-hidden flex font-sans text-white bluue scrollbar-thin-gray pb-0">
  <div id="page-loader"
    class="fixed inset-0 bg-gray-900/10 backdrop-blur-sm z-50 flex flex-col items-center justify-center transition-opacity duration-500 opacity-100">
    <div class="w-10 h-10 border-4 border-blue-500 border-t-transparent rounded-full animate-spin"></div>
    <p class="mt-4 text-gray-300 text-xs uppercase tracking-widest">Loading Fution...</p>
  </div>
  <!-- mobile overlay for menu -->
  <div id="mobile-overlay" class="fixed inset-0 bg-black bg-opacity-50 z-40 hidden lg:hidden"></div>

  <!-- top header for mobile -->
  <div class="fixed top-0 left-0 right-0 z-50 flex lg:hidden">
    <!-- mobile menu toggle button -->
    <button id="mobile-menu-toggle"
      class="w-12 h-16 bg-gradient-to-t from-gray-800 to-gray-900 border-b border-gray-700 flex items-center justify-center hover:bg-gray-700/50 transition-all duration-200 bg-gray-800">
      <div class="w-6 h-6 flex flex-col justify-center space-y-1">
        <span class="block w-6 h-0.5 bg-white transition-all duration-200" id="bar1"></span>
        <span class="block w-6 h-0.5 bg-white transition-all duration-200" id="bar2"></span>
        <span class="block w-6 h-0.5 bg-white transition-all duration-200" id="bar3"></span>
      </div>
    </button>
    <!-- mobile header content -->
    <header
      class="flex-1 bg-gradient-to-t from-gray-800 to-gray-900 h-16 border-b border-gray-700 border-opacity-70 flex items-center justify-between px-4 rounded-r-lg">
      <div class="flex items-center gap-2">
        <img src="logo.png" alt="Fution Logo" class="w-10 h-10 rounded-lg" />
        <h2 class="text-lg font-bold">Fution - Week 04</h2>
      </div>
  </div>
  </header>
  </div>


  <!-- Modal Wrapper -->
  <div id="requestModal"
    class="fixed inset-0 bg-black/50 backdrop-blur-md flex items-center justify-center z-[9999] opacity-0 pointer-events-none transition-opacity duration-300 ease-in-out">

    <div
      class="bg-gradient-to-br from-gray-900/90 to-gray-800/90 text-white rounded-2xl w-full max-w-lg shadow-2xl border border-blue-500/20 p-6 relative transform scale-95 transition-all duration-300 ease-out animate-fade-in">

      <!-- Close Button -->
      <button id="closeModal"
        class="absolute top-3 right-3 text-gray-400 hover:text-red-400 text-2xl transition-all duration-200">&times;</button>

      <!-- Modal Title -->
      <h2 class="text-2xl font-bold  text-blue-400 tracking-wide">Request to add a New Pending</h2>
      <p class="text-gray-400 mb-6">Please fill out the form below to request a new pending topic.</p>

      <!-- Form -->
      <form id="topicRequestForm" class="space-y-5">

        <div>
          <label for="email" class="block text-sm font-medium text-gray-300 mb-1">Your Email</label>
          <input type="email" id="email" name="email" required
            class="w-full px-4 py-2 rounded-lg bg-gray-800 border border-gray-700 focus:outline-none focus:ring-2 focus:ring-blue-500/60 focus:border-blue-400 transition placeholder:text-gray-500"
            placeholder="gandhiji@nehru.com">
        </div>

        <div>
          <label for="topic" class="block text-sm font-medium text-gray-300 mb-1">Pending Title</label>
          <input type="text" id="topic" name="topic" required
            class="w-full px-4 py-2 rounded-lg bg-gray-800 border border-gray-700 focus:outline-none focus:ring-2 focus:ring-blue-500/60 focus:border-blue-400 transition placeholder:text-gray-500"
            placeholder="e.g., Responsive Grid Systems">
        </div>

        <div>
          <label for="description" class="block text-sm font-medium text-gray-300 mb-1">Description (HTML
            allowed)</label>
          <textarea id="description" name="description" rows="4" required
            class="w-full px-4 py-2 rounded-lg bg-gray-800 border border-gray-700 focus:outline-none focus:ring-2 focus:ring-blue-500/60 focus:border-blue-400 transition placeholder:text-gray-500"
            placeholder="<p>A responsive grid system is a layout structure that adapts its columns and rows to different screen sizes, ensuring content remains well-organized and visually appealing across various devices</p>"></textarea>
        </div>

        <button type="submit"
          class="w-full px-5 py-2.5 rounded-lg border border-gray-600 hover:bg-blue-700 shadow-lg hover:shadow-blue-500/40 transition font-semibold text-white tracking-wide">
          Submit Request
        </button>
      </form>
    </div>
  </div>

  <!-- toast -->
  <div id="fusionToast"
    class="fixed top-5 right-5 z-50 hidden px-6 py-4 rounded-lg shadow-lg text-white bg-gradient-to-r from-blue-900/60 to-black/60 border border-gray-700 animate-slide-in">
    <p id="toastMessage" class="font-sans"></p>
  </div>




  <!-- main content area -->
  <main class="lg:ml-96 flex-1 relative overflow-hidden">

    <div class="p-2 lg:p-8 pt-20 lg:pt-2 lg:pb-2 overflow-y-auto h-full">
      <!-- week header section -->
      <div class="grid lg:grid-cols-3 gap-6 text-center mb-8 sm:mt-10 fade-up lg:pr-24">
        <!-- Week Header - takes 2 columns on large screens -->
        <div class="lg:col-span-2">
          <div
            class="inline-flex items-center space-x-4 border border-gray-700 border-opacity-70 px-6 py-4 rounded-2xl mb-6">
            <div class="w-16 h-16 flex items-center justify-center">
              <img src="https://www.vectorlogo.zone/logos/nodejs/nodejs-icon.svg" alt="Week 4 Icon" class="w-12 h-12" />
            </div>
            <div class="text-left">
              <h1 class="text-3xl lg:text-4xl font-bold">Week 04</h1>
              <p class="text-gray-400 text-lg">NOOODE JS</p>
            </div>
          </div>
        </div>

        <!-- Progress Tracker - takes 1 column on large screens -->
        <div class="flex items-center pr-12 justify-center gap-6">
          <div class="relative">
            <svg class="w-24 h-24" viewBox="0 0 96 96">
              <defs>
                <radialGradient id="glow" cx="50%" cy="50%" r="50%">
                  <stop offset="0%" stop-color="#3b82f6" stop-opacity="0.25" />
                  <stop offset="100%" stop-color="#3b82f6" stop-opacity="0" />
                </radialGradient>
              </defs>
              <g transform="rotate(-90 48 48)">
                <circle cx="48" cy="48" r="40" fill="url(#glow)" />
                <circle cx="48" cy="48" r="44" stroke="currentColor" stroke-width="1" fill="transparent"
                  class="text-gray-700/10" />
                <circle cx="48" cy="48" r="34" stroke="currentColor" stroke-width="1.5" fill="transparent"
                  class="text-gray-700/30" />
                <circle cx="48" cy="48" r="40" stroke="currentColor" stroke-width="6" fill="transparent"
                  class="text-gray-700/60" />
                <circle cx="48" cy="48" r="40" stroke="currentColor" stroke-width="6" fill="transparent"
                  stroke-dasharray="251.2" stroke-dashoffset="251.2" class="text-blue-500" id="main-progress"
                  style="transition: stroke-dashoffset 0.6s cubic-bezier(.4,2,.6,1);" stroke-linecap="round" />
              </g>
            </svg>
            <div class="absolute inset-0 flex flex-col items-center justify-center">
              <span class="text-2xl font-extrabold text-white drop-shadow" id="progress-text">0%</span>
              <span class="text-xs text-gray-400 mt-1 tracking-wide" id="progress-count">0 / 0</span>
            </div>
          </div>
          <div class="flex flex-col justify-center">
            <div class="text-lg font-semibold text-white/90 tracking-tight flex items-center gap-2">
              Progress Tracker
            </div>
            <div class="text-sm text-gray-400 mt-1">Track your weekly mastery</div>
            <div class="flex items-center gap-2 mt-2">
              <div class="w-2 h-2 rounded-full bg-blue-500 animate-pulse"></div>
              <span class="text-xs text-gray-500">Auto-saves progress</span>
            </div>
          </div>
        </div>
      </div>


      <!-- content grid layout -->
      <div class="grid lg:grid-cols-3 gap-6 lg:gap-8" >

        <div class="lg:col-span-2 space-y-6" >
          <div
            class="border border-gray-700 border-opacity-70 rounded-2xl lg:p-5 p-3 pt-5 slide-left lg:h-[calc(100vh-220px)] lg:w-full w-[calc(100vw-10px)]" id="mainBox">

            <div class="flex items-center justify-between mb-6" >
              <div
                class="tab-buttons flex gap-1 relative bg-white/5 rounded-full p-1 backdrop-blur-md border border-white/10">
                <button data-tab="topics" class="tab-btn active-tab" onclick="switchTab('topics')">Topics</button>
                <button data-tab="practicals" class="tab-btn" onclick="switchTab('practicals')">Practicals</button>
                <span class="tab-highlight"></span>
              </div>

              <button id="requestTopicBtn"
                class="text-sm px-4 py-2 rounded-lg bg-transparent border border-gray-700 hover:bg-blue-700 transition text-white font-medium">
                Add Pending
              </button>
            </div>

            <div id="tab-topics"
              class="tab-content lg:overflow-y-auto lg:h-[calc(100vh-350px)] lg:px-4 space-y-3 scrollbar-thin-gray">
              <div id="topicsContainer"></div>
            </div>

            <div id="tab-practicals"
              class="tab-content hidden lg:overflow-y-auto lg:h-[calc(100vh-350px)] lg:px-4 space-y-3 scrollbar-thin-gray">
              <div id="practicalsContainer" class="grid grid-cols-1 gap-4">
                <!-- Practicals will be rendered dynamically here -->
              </div>
            </div>


          </div>
        </div>


        <!-- pro tips  -->

        <div class="space-y-6">
          <div
            class="border border-gray-700 border-opacity-70 rounded-2xl p-6 slide-right lg:overflow-y-auto h-[calc(100vh-220px)] scrollbar-thin-gray ">
            <div class="flex items-center space-x-3 mb-6">
              <div
                class="w-10 h-10 bg-blue-500 bg-opacity-20 border border-blue-500 border-opacity-40 rounded-lg flex items-center justify-center">
                <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z">
                  </path>
                </svg>
              </div>
              <h2 class="text-xl font-bold">Pro Tips</h2>
            </div>
            <div id="pro-tips-list" class="space-y-4"></div>
          </div>
        </div>
      </div>
    </div>
  </main>

  <script>
    window.weekKey = "week4";

    window.topics = [
      {
        type: 'heading',
        title: "Core Node.js",
      },
        {
    title: "What is Node.js?",
    difficulty: "Beginner",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I understand that Node.js is a back-end JavaScript runtime. It uses the V8 engine to execute JavaScript, but extends its capabilities with C++ bindings and a library called libuv to handle asynchronous, non-blocking I/O, which makes it efficient for building scalable network applications."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>Node.js is a server-side environment, not a programming language or a framework. It allows you to run JavaScript code <strong>outside</strong> of a web browser. It's built on three main components:</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong>V8 Engine:</strong> Google's high-performance JavaScript engine (the same one used in Chrome). It compiles your JS code into optimized machine code.</li>
            <li><strong>libuv:</strong> A C++ library that provides the <strong>event loop</strong>, a thread pool, and other asynchronous I/O operations (like file access, networking, and timers). This is the key to Node's non-blocking, concurrent nature.</li>
            <li><strong>C++ Bindings:</strong> These are the 'glue' that connect V8 (which 'speaks' JavaScript) with libuv and other low-level operating system features, allowing your JS code to do things a browser can't, like <code>require('fs')</code>.</li>
          </ul>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (A Simple Web Server)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
// Use the built-in 'http' module (CommonJS syntax)
const http = require('http');

const hostname = '127.0.0.1';
const port = 3000;

// Create a server object
const server = http.createServer((req, res) => {
  // This callback function runs for every new request
  res.statusCode = 200;
  res.setHeader('Content-Type', 'text/plain');
  res.end('Hello, World!\\n');
});

// Start listening for connections
server.listen(port, hostname, () => {
  // This callback runs once the server is ready
  console.log(\`Server running at http://\\\${hostname}:\\\${port}/\`);
});
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Terminal Commands</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-bash">
# Save the code above as server.js

# To run the server:
$ node server.js

# Output:
# Server running at http://127.0.0.1:3000/
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>Node.js allows front-end developers to use their existing JavaScript skills to build full-stack applications. Its non-blocking, event-driven architecture is extremely efficient for I/O-heavy tasks like web servers, APIs, and real-time applications (e.g., chat apps, game servers) where the server spends most of its time waiting for data.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>What is the Event Loop and what is its role?</li>
            <li>You mentioned libuv. What does it do that V8 doesn't?</li>
            <li>Is Node.js single-threaded or multi-threaded? (Trick question: The event loop is single-threaded, but libuv uses a thread pool for heavy I/O).</li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "Node.js vs. Browser.js",
    difficulty: "Beginner",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I know that both environments run JavaScript, but their key difference lies in their APIs. The browser provides web-specific APIs like the DOM, 'window', and 'fetch', while Node.js provides server-side APIs for file systems ('fs'), networking ('http'), and operating system access ('os')."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>While both Node and browsers use a JavaScript engine (like V8), they are built for different purposes and have different global objects and capabilities.</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong>Browser JS:</strong> Runs in a secure 'sandbox' for safety. Its main job is to interact with a user through a UI. It has global objects like <code>window</code> and <code>document</code> and provides APIs for web interaction (DOM, fetch, localStorage).</li>
            <li><strong>Node.js:</strong> Runs on a server with more permissions. Its main job is to handle requests, access databases, and read/write files. It has global objects like <code>global</code> and <code>process</code> and provides APIs for server tasks (fs, http, os, path).</li>
          </ul>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (Code differences)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
// --- Code that ONLY works in Node.js ---
const fs = require('fs');
const os = require('os');

console.log('OS Platform:', os.platform());
try {
  // Try to write a file
  fs.writeFileSync('hello.txt', 'Hello from Node.js!');
  console.log('File written successfully.');
} catch (err) {
  console.error('Error writing file:', err);
}

// --- Code that ONLY works in the Browser ---
/*
// This code will FAIL in Node.js, as 'document' is not defined
// (and 'fs' is not defined in the browser)

const heading = document.getElementById('my-heading');
if (heading) {
  heading.textContent = 'Hello from the Browser!';
}
console.log(window.location.href);
*/
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>Understanding this separation is crucial. You can't manipulate a webpage's DOM from a Node.js server, and you can't access a server's file system directly from browser JavaScript. This distinction defines the client-server model and explains why you need both parts for a full-stack web application.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>What is the 'process' object in Node.js?</li>
            <li>How would you share code (e.g., validation logic) between a Node.js backend and a browser frontend? (e.g., using ES modules, bundling).</li>
            <li>If 'fetch' is a browser API, why can I use it in Node.js? (It was added as a global in Node v18+, but for years required a library like 'node-fetch').</li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "Event-Driven Programming",
    difficulty: "Intermediate",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I understand Node.js is built on an event-driven model. Instead of code running top-to-bottom, it registers 'listener' functions that execute in response to specific events. This is handled by the event loop, which allows Node to manage many concurrent operations without blocking."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>In event-driven programming, the flow of the program is determined by events, such as a user click, an HTTP request, or a timer completing. In Node, you create functions (callbacks or "listeners") and attach them to specific events. The Node.js <code>EventEmitter</code> class is the foundation for this pattern, and many built-in modules (like HTTP servers, streams, and file reads) use it.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (Using EventEmitter)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
// Import the built-in 'events' module
const EventEmitter = require('events');

// Create a new event emitter instance
class MyEmitter extends EventEmitter {}
const myEmitter = new MyEmitter();

// 1. Register a listener (a callback) for the 'userLogin' event
myEmitter.on('userLogin', (username) => {
  console.log(\`EVENT: User '\${username}' logged in at \${new Date()}\`);
});

// 2. Register another listener for the same event
myEmitter.on('userLogin', (username) => {
  console.log(\`EVENT: Sending welcome email to '\${username}'...\`);
});

// 3. Emit (or "fire") the 'userLogin' event with data
console.log('Emitting event...');
myEmitter.emit('userLogin', 'alice');
console.log('Event emitted.');

// Note: The built-in http.createServer is also an event emitter!
// server.on('request', (req, res) => { ... });
// fs.createReadStream().on('data', (chunk) => { ... });
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>This pattern is the heart of Node.js. It's what allows a single-threaded event loop to handle thousands of concurrent connections. Instead of one thread waiting for a database query to return, it can register a "database complete" event and go service other requests. This is far more efficient and scalable than the traditional thread-per-request model used by other servers.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>What's the difference between <code>on()</code> and <code>once()</code> in an EventEmitter?</li>
            <li>How can you remove an event listener? (<code>removeListener()</code> or <code>off()</code>)</li>
            <li>How does this pattern relate to callbacks and Promises? (They all handle async results, but EventEmitter is for 'many listeners for one event' or 'one event firing multiple times').</li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "Synchronous vs. Asynchronous Execution",
    difficulty: "Beginner",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I know that synchronous code executes line-by-line, and the next line can't run until the current one finishes, which 'blocks' the program. Asynchronous code starts an operation (like a file read) and allows the rest of the program to continue. A callback function is then executed once the operation completes."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong>Synchronous (Sync):</strong> Like following a recipe one step at a time. You must finish "chopping vegetables" before you can "start saut√©ing." If chopping takes 10 minutes, the stove is idle for 10 minutes. This is 'blocking'.</li>
            <li><strong>Asynchronous (Async):</strong> Like putting laundry in the washing machine. You *start* the machine (the async operation) and then you are free to "read a book" (run other code) while it's running. The machine "beeps" (the callback) when it's done. This is 'non-blocking'.</li>
          </ul>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (Reading a file)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
const fs = require('fs');

// Create a file to read (sync is ok for setup)
fs.writeFileSync('example.txt', 'This is test data.');

// --- 1. Synchronous Example (Blocks the program) ---
console.log('--- SYNC ---');
console.log('1. Before sync read');
try {
  const data = fs.readFileSync('example.txt', 'utf8');
  console.log('2. Sync Read Data:', data);
} catch (err) {
  console.error('Sync Error:', err);
}
console.log('3. After sync read');


// --- 2. Asynchronous Example (Non-blocking) ---
console.log('\\n--- ASYNC ---');
console.log('4. Before async read');
fs.readFile('example.txt', 'utf8', (err, data) => {
  // This callback runs later, when the file read is complete
  if (err) {
    console.error('Async Error:', err);
    return;
  }
  console.log('6. Async Read Data:', data);
});
console.log('5. After async read (This logs *before* 6!)');

// Clean up (sync is fine here)
fs.unlinkSync('example.txt');

// Expected Output:
// --- SYNC ---
// 1. Before sync read
// 2. Sync Read Data: This is test data.
// 3. After sync read
//
// --- ASYNC ---
// 4. Before async read
// 5. After async read (This logs *before* 6!)
// 6. Async Read Data: This is test data.
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>Using synchronous functions in a Node.js server is dangerous. A single <code>readFileSync</code> or other blocking call will freeze the <strong>entire</strong> server. No other users can be served, and no other code can run, until that operation completes. Always use the asynchronous versions (with callbacks, Promises, or async/await) in a server environment.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>When would it ever be appropriate to use a synchronous function like <code>readFileSync</code>? (e.g., in a build script, or once at server startup to load a config file, before the server starts listening).</li>
            <li>How do Promises and async/await improve on this callback-based model?</li>
            <li>What is 'callback hell' and how do you avoid it?</li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "Blocking vs. Non-Blocking I/O",
    difficulty: "Intermediate",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "This concept is central to Node.js. Blocking I/O means a thread is paused, waiting for an operation like a disk read to complete. Non-blocking I/O allows the thread to continue, and the operation's completion is signaled later via the event loop. Node.js uses non-blocking I/O for almost everything to achieve high concurrency."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>This is the low-level implementation of the sync/async concept. <strong>I/O</strong> stands for Input/Output (e.g., file reads, network requests, database queries).</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong>Blocking I/O:</strong> <code>fs.readFileSync()</code>. The Node.js main thread literally stops and waits for the operating system to return the file data. This thread is 'blocked' and can do nothing else.</li>
            <li><strong>Non-Blocking I/O:</strong> <code>fs.readFile()</code>. The Node.js main thread hands the request to <code>libuv</code>. <code>libuv</code> tells the OS to get the file and *immediately* returns control to the Node.js thread, which can continue executing code. When the OS has the data, it notifies <code>libuv</code>, which then queues the callback in the event loop.</li>
          </ul>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (Simulating a slow operation)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
// --- 1. Blocking 'sleep' function ---
// DO NOT EVER DO THIS IN A REAL NODE SERVER
function blockingSleep(ms) {
  console.log('   (BLOCK: START - Freezing the event loop...)');
  const start = Date.now();
  // This 'while' loop ties up the entire CPU,
  // blocking the event loop completely.
  while (Date.now() < start + ms) { /* spin */ }
  console.log('   (BLOCK: END)');
}

// --- 2. Non-blocking 'sleep' (using setTimeout) ---
function nonBlockingSleep(ms) {
  console.log('   (NON-BLOCK: START - Registering timer...)');
  return new Promise((resolve) => {
    // setTimeout is non-blocking. It registers an event.
    setTimeout(() => {
      console.log('   (NON-BLOCK: END - Timer event fired.)');
      resolve();
    }, ms);
  });
}
        
// --- Demonstration ---
async function runTest() {
  console.log('Test Start');
  
  // Set a timer that will try to fire in 1s
  // It gets added to the event queue.
  setTimeout(() => console.log('>>> Timer Fired! <<<'), 1000);
  
  // --- Blocking ---
  blockingSleep(2000);
  // The 1s timer *could not* fire because the loop was blocked.
  // It will fire *after* this blocking code finishes.
  console.log('After blocking sleep.');

  console.log('\\n---');

  // --- Non-Blocking ---
  // Set a timer that will try to fire in 1s
  setTimeout(() => console.log('>>> Timer Fired! <<<'), 1000);

  await nonBlockingSleep(2000);
  // The 1s timer *was able* to fire on time,
  // because the event loop was not blocked.
  console.log('After non-blocking sleep.');
}

runTest();
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>Node.js's performance model is based on being non-blocking. A "blocking" call isn't just slow for one user; it's slow for <strong>all</strong> users. Understanding this is the #1 rule of writing performant Node.js code. Even CPU-intensive code (like a complex loop or <code>JSON.parse</code> on a huge file) can be 'blocking' and should be handled with care (e.g., using worker threads).</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>Is all Node.js code non-blocking? (No. Heavy JSON parsing or a complex loop can also block the event loop, even if it's not I/O).</li>
            <li>How does <code>libuv</code>'s thread pool fit in? (For some I/O that can't be done non-blocking at the OS level (like <code>fs</code>), <code>libuv</code> runs it in a separate thread pool, so the *main* event loop thread remains non-blocking).</li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "The REPL",
    difficulty: "Beginner",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I've used the Node.js REPL for quick experiments. It's a 'Read-Eval-Print-Loop' that lets me type in JavaScript, have it evaluated, see the result printed, and then get the prompt back. It's great for testing small snippets, learning APIs, or debugging."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>The REPL is an interactive shell for Node.js. You can access it by typing <code>node</code> in your terminal with no arguments. It's an excellent tool for learning and experimenting.</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong>Read:</strong> It *reads* what you type (e.g., <code>1 + 1</code>).</li>
            <li><strong>Eval:</strong> It *evaluates* the code.</li>
            <li><strong>Print:</strong> It *prints* the result (e.g., <code>2</code>).</li>
            <li><strong>Loop:</strong> It *loops* back to the start, giving you a prompt (<code>&gt;</code>).</li>
          </ul>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (A REPL Session)</h2>
          <p class="mb-2">There is no code file for this. The example is the terminal session itself.</p>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-bash">
# Start the Node.js REPL by typing 'node'
$ node
> Welcome to Node.js v18.18.0.
> Type ".help" for more information.

# 1. Evaluate simple expressions
> 10 * 5
50

# 2. Use the special '_' variable to get the last result
> _ + 7
57

> 'Hello' + ' ' + 'REPL'
'Hello REPL'

# 3. Create variables and functions
> let x = 10;
undefined
> function add(a, b) { return a + b; }
undefined
> add(x, 5)
15

# 4. Use built-in Node.js modules
> const os = require('os');
undefined
> os.cpus().length
8

# 5. Use REPL commands
> .help
.break    Sometimes you get stuck, this gets you out
.clear    Break, clear, and reload global object
.exit     Exit the REPL
.help     Print this help message
.load     Load JS from a file into the REPL session
.save     Save all evaluated commands in this REPL session to a file

# 6. Exit the REPL
> .exit
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>The REPL is a fantastic, zero-setup tool for learning. You can explore entire modules like <code>fs</code> or <code>path</code> interactively without having to create and run a <code>.js</code> file. It's an essential part of a developer's toolkit for quick prototyping, testing logic, and debugging.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>How can you load a JavaScript file into the REPL? (<code>.load my_file.js</code>)</li>
            <li>How do you save your REPL session to a file? (<code>.save my_session.js</code>)</li>
            <li>What does the Type ".help" for more information. (dot) prefix mean on commands like <code>.exit</code>? (It signals a REPL-specific command, not JavaScript code).</li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "CommonJS vs. ES Modules",
    difficulty: "Intermediate",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I know the two module systems in Node.js. CommonJS uses 'require' and 'module.exports' and is synchronous. ES Modules (ESM) use 'import' and 'export' and are asynchronous. I understand that ESM is the modern standard, but CommonJS is still prevalent in older codebases."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>Node.js originally used <strong>CommonJS (CJS)</strong>. The new official standard for JavaScript (and now Node.js) is <strong>ES Modules (ESM)</strong>.</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong>CommonJS (CJS):</strong>
              <ul>
                <li>Import: <code>const fs = require('fs');</code></li>
                <li>Export: <code>module.exports = myFunction;</code></li>
                <li>Loading is <strong>synchronous</strong>.</li>
                <li>Files typically end in <code>.js</code> (by default) or <code>.cjs</code>.</li>
              </ul>
            </li>
            <li><strong>ES Modules (ESM):</strong>
              <ul>
                <li>Import: <code>import fs from 'fs';</code> or <code>import { myFunction } from './utils.js';</code></li>
                <li>Export: <code>export default myFunction;</code> or <code>export const myVar = 10;</code></li>
                <li>Loading is <strong>asynchronous</strong>.</li>
                <li>Files must end in <code>.mjs</code>, or you must set <code>"type": "module"</code> in your <code>package.json</code>.</li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example 1: CommonJS (Default)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
// --- utils.js ---
function sayHello(name) {
  return \`Hello, \${name}\`;
}
module.exports = { sayHello }; // Export an object

// --- index.js ---
const { sayHello } = require('./utils.js'); // Destructure the import
console.log(sayHello('CommonJS'));
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example 2: ES Modules</h2>
          <p class="mb-2">To run this, set <code>"type": "module"</code> in your <code>package.json</code> or name files with <code>.mjs</code>.</p>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
// --- utils.mjs ---
export function sayHello(name) { // Use 'export' keyword
  return \`Hello, \${name}\`;
}

// --- index.mjs ---
import { sayHello } from './utils.mjs'; // Use 'import'
console.log(sayHello('ES Modules'));
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>ESM is the standard across all modern JavaScript (both browser and server). It has benefits like static analysis (better for tools) and asynchronous loading. However, you will constantly encounter CommonJS in existing projects, documentation, and libraries, so you must be able to read and write both.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>What is <code>exports</code> vs. <code>module.exports</code>? (<code>exports</code> is just a shortcut to <code>module.exports</code>, but reassigning it (e.g., <code>exports = ...</code>) will break the link).</li>
            <li>Can you use <code>require</code> in an ES Module? (No, but you can use <code>import()</code> dynamically).</li>
            <li>How do you use <code>__dirname</code> and <code>__filename</code> in ES Modules? (They don't exist, but you can derive them using <code>import.meta.url</code>).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://nodejs.org/api/modules.html" target="_blank" class="hover:underline">Node.js Docs: Modules</a></li>
            <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules" target="_blank" class="hover:underline">MDN: JavaScript Modules</a></li>
            <li><a href="https://blog.logrocket.com/commonjs-vs-es-modules-in-node-js/" target="_blank" class="hover:underline">CommonJS vs. ES Modules in Node.js</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "Core Modules (Basics): fs & path",
    difficulty: "Beginner",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I'm comfortable with the 'fs' and 'path' core modules. I use 'fs' for file system operations, always preferring asynchronous methods like 'readFile' in a server, and 'path' (especially 'path.join') to build file paths reliably across different operating systems."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>Node.js has "core modules" (built-in libraries) that you can use without installing anything. Two of the most important are:</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong><code>fs</code> (File System):</strong> Allows you to interact with the file system to read, write, delete files, create directories, etc. It has both async (non-blocking) and sync (blocking) versions of its methods.</li>
            <li><strong><code>path</code>:</strong> A utility module for handling and transforming file paths in a cross-platform way. (e.g., handling <code>/</code> in Linux/macOS vs. <code>\\</code> in Windows).</li>
          </ul>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (Async read/write with path)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
const fs = require('fs');
const path = require('path');

// 1. Create a reliable path using path.join()
// This correctly builds 'temp/my-file.txt' on any OS
const filePath = path.join(__dirname, 'temp', 'my-file.txt');

// 2. Ensure the directory exists (optional, good practice)
// 'recursive: true' is like 'mkdir -p'
fs.mkdir(path.join(__dirname, 'temp'), { recursive: true }, (err) => {
  if (err) return console.error('Error creating directory:', err);
  
  const content = 'Hello from fs module!';

  // 3. Write a file asynchronously
  fs.writeFile(filePath, content, 'utf8', (err) => {
    if (err) return console.error('Error writing file:', err);

    console.log('File written successfully:', filePath);

    // 4. Read the file back asynchronously
    fs.readFile(filePath, 'utf8', (err, data) => {
      if (err) return console.error('Error reading file:', err);

      console.log('File content:', data);
    });
  });
});
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>Almost every Node.js application needs to interact with the file system, whether to serve HTML files, read configurations, or write logs. Using <code>fs</code> correctly (asynchronously) is key to a non-blocking server, and using <code>path</code> is key to writing robust code that works on any machine, not just yours.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>What's the difference between <code>fs.readFile</code> and <code>fs.readFileSync</code>? (One is async/non-blocking, the other is sync/blocking).</li>
            <li>What are <code>__dirname</code> and <code>__filename</code>? (Globals in CommonJS that give the directory and file path of the current module).</li>
            <li>What's the difference between <code>path.join</code> and <code>path.resolve</code>? (<code>join</code> just connects path segments; <code>resolve</code> builds an absolute path from right to left).</li>
          </ul>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://nodejs.org/api/fs.html" target="_blank" class="hover:underline">Node.js Docs: File System (fs)</a></li>
            <li><a href="https://nodejs.org/api/path.html" target="_blank" class="hover:underline">Node.js Docs: Path</a></li>
            <li><a href="https://developer.mozilla.org/en-US/docs/learn/Server-side/Nodejs/skeleton_server" target="_blank" class="hover:underline">MDN: Node.js core modules</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "NPM, NPX, and NVM",
    difficulty: "Beginner",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I use these three tools all the time. 'nvm' lets me switch between Node.js versions, 'npm' is the package manager I use to install and manage project dependencies like Express or Nodemon, and 'npx' is a tool to execute packages without installing them globally."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>These are three distinct command-line tools for managing the Node.js ecosystem.</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong><code>nvm</code> (Node Version Manager):</strong> A tool to manage multiple versions of Node.js on your computer. This is crucial for switching between projects that require different Node versions (e.g., Node 16 vs. Node 20).</li>
            <li><strong><code>npm</code> (Node Package Manager):</strong> The default package manager for Node.js. It's used to install, update, and manage project dependencies (the libraries your project needs) which are listed in <code>package.json</code>.</li>
            <li><strong><code>npx</code> (Node Package Execute):</strong> A package *runner* that comes with npm. It's used to run commands from a package without having to install it globally or locally.</li>
          </ul>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (Terminal Commands)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-bash">
# --- NVM (Node Version Manager) ---

# Install Node.js version 20
$ nvm install 20

# Use version 20 in this terminal session
$ nvm use 20

# List all installed versions
$ nvm ls


# --- NPM (Node Package Manager) ---
# (Run inside your project directory)

# Initialize a new project (creates package.json)
$ npm init -y

# Install 'express' and save it as a project dependency
$ npm install express

# Install 'nodemon' as a dev-only dependency
$ npm install nodemon --save-dev
# or 'npm i nodemon -D'

# Install all dependencies from package.json
$ npm install


# --- NPX (Node Package Execute) ---

# Create a new React app without globally installing 'create-react-app'
$ npx create-react-app my-new-app

# Run a local binary (like nodemon) from node_modules/.bin
$ npx nodemon server.js
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>Modern web development is built on packages. <code>nvm</code> gives you a stable environment, <code>npm</code> manages your project's "ingredients" (dependencies), and <code>npx</code> provides a clean way to use command-line tools without cluttering your system with global installs. Mastering these commands is non-negotiable for Node.js development.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>What's the difference between <code>npm install</code> and <code>npm ci</code>? (<code>ci</code> is for "clean install," it uses <code>package-lock.json</code> and is faster/safer for build servers).</li>
            <li>What is a global install (<code>npm i -g</code>) and when would you use it? (For tools you use everywhere, like <code>nvm</code> itself, though <code>npx</code> is often preferred).</li>
            <li>What is <code>yarn</code> or <code>pnpm</code>? (Alternative package managers to <code>npm</code>).</li>
          </ul>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://github.com/nvm-sh/nvm" target="_blank" class="hover:underline">NVM GitHub Repository</a></li>
            <li><a href="https://docs.npmjs.com/about-npm" target="_blank" class="hover:underline">NPM Docs: About NPM</a></li>
            <li><a href="https://docs.npmjs.com/cli/v10/commands/npx" target="_blank" class="hover:underline">NPM Docs: npx</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "package.json",
    difficulty: "Beginner",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I understand that 'package.json' is the manifest file for a Node.js project. It holds metadata like the project's name and version, defines runnable 'scripts' for tasks, and, most importantly, lists all 'dependencies' (for production) and 'devDependencies' (for development)."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>The <code>package.json</code> file is the "heart" of any Node.js project. It's a JSON file that lives in the root of your project and contains essential information. Key fields include:</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong><code>name</code>, <code>version</code>, <code>description</code>:</strong> Basic info about your project.</li>
            <li><strong><code>main</code>:</strong> The entry point to your application (e.g., <code>index.js</code>).</li>
            <li><strong><code>"type"</code>:</strong> (Optional) Sets the module system, e.g., <code>"module"</code> to enable ES Modules.</li>
            <li><strong><code>scripts</code>:</strong> A place to define command-line shortcuts, like <code>"start": "node server.js"</code>, which you run with <code>npm start</code>.</li>
            <li><strong><code>dependencies</code>:</strong> A list of packages your application needs to *run* (e.g., <code>express</code>, <code>axios</code>).</li>
            <li><strong><code>devDependencies</code>:</strong> A list of packages only needed for *development* (e.g., <code>nodemon</code>, <code>jest</code>, <code>eslint</code>).</li>
          </ul>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (A typical package.json)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-json">
{
  "name": "my-cool-api",
  "version": "1.0.0",
  "description": "A demo API for my project",
  "main": "server.js",
  "type": "commonjs",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "test": "jest"
  },
  "dependencies": {
    "express": "^4.18.2"
  },
  "devDependencies": {
    "jest": "^29.7.0",
    "nodemon": "^3.0.1"
  },
  "author": "Your Name",
  "license": "ISC"
}
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Terminal Commands</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-bash">
# Create a default package.json
$ npm init -y

# Run the 'start' script
$ npm start

# Run the 'dev' script
$ npm run dev

# Run the 'test' script
$ npm test
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>This file makes your project portable and reproducible. Anyone can clone your project, run <code>npm install</code>, and get the exact same dependencies. The <code>scripts</code> section standardizes how to start, test, and build your project, making it easy for you (and others) to work on.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>What's the difference between <code>dependencies</code> and <code>devDependencies</code>? (One is for production, the other is for development).</li>
            <li>What is semantic versioning (SemVer)? (The <code>^4.18.2</code> syntax, which means <code>^</code>Major.Minor.Patch).</li>
            <li>How do you run a script that isn't named "start" or "test"? (<code>npm run &lt;script-name&gt;</code>).</li>
          </ul>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://docs.npmjs.com/cli/v10/configuring-npm/package-json" target="_blank" class="hover:underline">NPM Docs: package.json</a></li>
            <li><a href="https://nodejs.org/en/learn/getting-started/an-introduction-to-npm" target="_blank" class="hover:underline">Node.js Docs: Introduction to npm</a></li>
            <li><a href="https://semver.org/" target="_blank" class="hover:underline">Semantic Versioning (SemVer)</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "package-lock.json",
    difficulty: "Intermediate",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I know that 'package-lock.json' is an automatically generated file. Its purpose is to lock down the exact versions of all dependencies and sub-dependencies, ensuring that every 'npm install' results in the exact same 'node_modules' tree. This guarantees deterministic builds."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>The <code>package-lock.json</code> file is a "snapshot" of your entire dependency tree, from your direct dependencies (like <code>express</code>) to their dependencies, and so on.</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong>Problem:</strong> Your <code>package.json</code> might say <code>"express": "^4.18.2"</code>. The <code>^</code> means "any version from 4.18.2 up to (but not including) 5.0.0". If a new version (e.g., 4.19.0) is released, <code>npm install</code> might pull it, potentially introducing breaking changes.</li>
            <li><strong>Solution:</strong> The <code>package-lock.json</code> records the *exact* version (e.g., <code>"version": "4.18.2"</code>) that was installed. When you run <code>npm install</code>, npm uses this file to fetch those exact versions, ignoring the <code>^</code>.</li>
          </ul>
          <p class="mt-2">This file is auto-generated by <code>npm</code> and <strong>you should never edit it manually</strong>. You should always commit it to source control (e.g., Git).</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (Snippet from a lock file)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-json">
{
  "name": "my-cool-api",
  "version": "1.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "my-cool-api",
      "version": "1.0.0",
      "dependencies": {
        "express": "^4.18.2"
      }
    },
    "node_modules/accepts": {
      "version": "1.3.8",
      "resolved": "https://registry.npmjs.org/accepts/-/accepts-1.3.8.tgz",
      "integrity": "sha512-...",
      "dependencies": {
        "mime-types": "~2.1.34",
        "negotiator": "0.6.3"
      }
    },
    "node_modules/express": {
      "version": "4.18.2",
      "resolved": "https://registry.npmjs.org/express/-/express-4.18.2.tgz",
      "integrity": "sha512-...",
      "dependencies": {
        "accepts": "~1.3.8",
        "array-flatten": "1.1.1",
        "content-disposition": "0.5.4",
        "cookie": "0.5.0",
        "etag": "~1.8.1",
        "finalhandler": "1.2.0",
        "proxy-addr": "~2.0.7",
        "serve-static": "1.15.0",
        "utils-merge": "1.0.1",
        "vary": "~1.1.2"
      },
      "engines": { "node": ">= 0.10.0" }
    },
    "...": "..."
  }
}
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>The <code>package-lock.json</code> file ensures that your project works the same way on your machine, your co-worker's machine, and your production server. It prevents the "but it works on my machine" problem by guaranteeing that everyone on the team and in production is using the exact same code.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>Should I commit <code>package-lock.json</code> to Git? (<strong>Yes, always.</strong>)</li>
            <li>What is <code>npm ci</code> and how does it use this file? (<code>npm ci</code> does a "clean install" strictly from the lock file and is used in build pipelines).</li>
            <li>What happens if I manually edit <code>package.json</code>? (The next <code>npm install</code> will update the lock file to match).</li>
          </ul>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://docs.npmjs.com/cli/v10/configuring-npm/package-lock-json" target="_blank" class="hover:underline">NPM Docs: package-lock.json</a></li>
            <li><a href="https://docs.npmjs.com/cli/v10/commands/npm-ci" target="_blank" class="hover:underline">NPM Docs: npm ci</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "The `node_modules` folder",
    difficulty: "Beginner",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I know the 'node_modules' folder is where npm installs all the actual code for my project's dependencies. It's often very large because it contains not just my direct dependencies, but all of *their* dependencies as well. I also know it should never be committed to source control."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>The <code>node_modules</code> folder is the directory where npm places all the packages (the actual JavaScript code, <code>package.json</code> files, etc.) that your project depends on.</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li>When you run <code>npm install</code>, npm reads your <code>package.json</code> and <code>package-lock.json</code>.</li>
            <li>It downloads all the packages listed (like <code>express</code>) and all the packages *they* depend on (like <code>cookie</code>), and so on.</li>
            <li>It places all of this code into the <code>node_modules</code> folder.</li>
            <li>When you <code>require('express')</code>, Node.js knows to look for it inside this folder.</li>
          </ul>
          <p class="mt-2">This folder can become very large and <strong>should always be added to your <code>.gitignore</code> file</strong>. It can be completely regenerated at any time by running <code>npm install</code>.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (What it looks like)</h2>
          <p class="mb-2">There is no code for this, just a file structure concept.</p>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-bash">
# Your project directory structure:

my-project/
‚îú‚îÄ‚îÄ node_modules/     <-- THIS FOLDER (IGNORED BY GIT)
‚îÇ   ‚îú‚îÄ‚îÄ accepts/      (sub-dependency of express)
‚îÇ   ‚îú‚îÄ‚îÄ cookie/       (sub-dependency of express)
‚îÇ   ‚îú‚îÄ‚îÄ express/      (your direct dependency)
‚îÇ   ‚îú‚îÄ‚îÄ jest/         (your dev dependency)
‚îÇ   ‚îî‚îÄ‚îÄ ... (many, many more folders)
‚îÇ
‚îú‚îÄ‚îÄ package-lock.json
‚îú‚îÄ‚îÄ package.json
‚îî‚îÄ‚îÄ server.js
            </code></pre>
          </div>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (.gitignore file)</h2>
          <p class="mb-2">This file tells Git to ignore <code>node_modules</code>.</p>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-bash">
# .gitignore

# Dependencies
/node_modules

# Log files
*.log

# Environment variables
.env
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>Committing <code>node_modules</code> to Git would bloat your repository with thousands of files that you don't own. The correct practice is to let every developer (and your server) run <code>npm install</code> to build this folder locally. This keeps your repository small and clean, containing only *your* application's source code.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>Why is the <code>node_modules</code> folder so large? (It contains all sub-dependencies, which creates a large tree of packages).</li>
            <li>Should I commit <code>node_modules</code> to Git? (<strong>No, never.</strong>)</li>
            <li>How do I remove the <code>node_modules</code> folder and reinstall? (<code>rm -rf node_modules && npm install</code>).</li>
          </ul>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://docs.npmjs.com/cli/v10/commands/npm-install" target="_blank" class="hover:underline">NPM Docs: npm install</a></li>
            <li><a href="https://git-scm.com/docs/gitignore" target="_blank" class="hover:underline">Git Docs: gitignore</a></li>
            <li><a href="https://www.freecodecamp.org/news/what-is-node-modules/" target="_blank" class="hover:underline">What is the node_modules folder? (freeCodeCamp)</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "View Engines (e.g., EJS)",
    difficulty: "Intermediate",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I use view engines like EJS to render dynamic HTML on the server. I know how to set the 'view engine' in Express, and then use 'res.render()' to pass data from my route handler into a template file, which is much cleaner than building HTML with string concatenation."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>A <strong>View Engine</strong> (or template engine) allows you to write "template" files (e.g., <code>.ejs</code>, <code>.pug</code>) that mix static HTML with dynamic code. When a request comes in, Express processes this template, injects data into it, and sends the final, rendered HTML to the user.</p>
          <p class="mt-2">EJS (Embedded JavaScript) is popular because it's just HTML with special tags for JavaScript:</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><code>&lt;%= ... %&gt;</code>: "Escaped" output. Inserts a variable, but escapes HTML (e.g., <code>&lt;</code> becomes <code>&amp;lt;</code>). Use this by default.</li>
            <li><code>&lt;%- ... %&gt;</code>: "Unescaped" output. Inserts data exactly as-is. <strong>Be careful with this</strong>; it's a security risk (XSS) if the data is from a user.</li>
            <li><code>&lt;% ... %&gt;</code>: Logic tag. For loops, if-statements, etc. No output.</li>
          </ul>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (Using EJS)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
// --- File: server.js ---
const express = require('express');
const app = express();
const path = require('path');

// 1. Set the view engine and views directory
app.set('view engine', 'ejs');
app.set('views', path.join(__dirname, 'views')); // Default is './views'

app.get('/user', (req, res) => {
  const userData = {
    name: 'Alex',
    isAdmin: true,
    bio: '&lt;b&gt;This is my bio&lt;/b&gt;', // Potentially unsafe data
    hobbies: ['Reading', 'Coding', 'Hiking']
  };
  
  // 2. Render the 'profile.ejs' template and pass data
  res.render('profile', { user: userData });
});

app.listen(3000, () => console.log('Server running...'));

// --- File: views/profile.ejs ---
// &lt;!DOCTYPE html&gt;
// &lt;html&gt;
// &lt;body&gt;
//   &lt;h1&gt;Hello, &lt;%= user.name %&gt;!&lt;/h1&gt;
//
//   &lt;h2&gt;Escaped Bio (Safe):&lt;/h2&gt;
//   &lt;p&gt;&lt;%= user.bio %&gt;&lt;/p&gt; &lt;!-- Renders as literal text: "<b>This is...</b>" --&gt;
//
//   &lt;h2&gt;Unescaped Bio (Unsafe):&lt;/h2&gt;
//   &lt;p&gt;&lt;%- user.bio %&gt;&lt;/p&gt; &lt;!-- Renders as bold HTML: <b>This is...</b> --&gt;
//
//   &lt;% if (user.hobbies.length &gt; 0) { %&gt;
//     &lt;h2&gt;Hobbies:&lt;/h2&gt;
//     &lt;ul&gt;
//       &lt;% user.hobbies.forEach(hobby =&gt; { %&gt;
//         &lt;li&gt;&lt;%= hobby %&gt;&lt;/li&gt;
//       &lt;% }); %&gt;
//     &lt;/ul&gt;
//   &lt;% } %&gt;
// &lt;/body&gt;
// &lt;/html&gt;
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>View engines are the backbone of Server-Side Rendering (SSR). They allow you to build dynamic, data-driven websites without needing a separate front-end framework. Even if you use a framework like React, your server might still use a view engine to render the initial HTML shell.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>What's the difference between EJS, Pug, and Handlebars? (EJS is "just HTML + JS," Pug uses indentation, Handlebars uses <code>{{...}}</code> syntax).</li>
            <li>What is the security risk of <code>&lt;%- ... %&gt;</code>? (Cross-Site Scripting (XSS). A user could set their bio to <code>&lt;script&gt;alert('hacked')&lt;/script&gt;</code>).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://ejs.co/" target="_blank" class="hover:underline">EJS Official Website</a></li>
            <li><a href="https://expressjs.com/en/guide/using-template-engines.html" target="_blank" class="hover:underline">Express Docs: Using template engines</a></li>
          </ul>
        </section>
      </div>
    `
  },

  //Http and server basics
  {
    type: 'heading',
    title: "Networking",
  },
    {
    title: "What is HTTP & HTTPS?",
    difficulty: "Beginner",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I understand HTTP as the protocol for client-server communication on the web, like a browser asking a server for a webpage. HTTPS is just the secure version, which encrypts the communication using SSL/TLS to protect user data."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p><strong>HTTP (Hypertext Transfer Protocol)</strong> is the foundational protocol of the World Wide Web. It's a simple, text-based set of rules that defines how a <strong>client</strong> (like your web browser) and a <strong>server</strong> (where a website is hosted) communicate with each other.</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong>Client:</strong> Makes requests (e.g., "Give me the homepage").</li>
            <li><strong>Server:</strong> Sends responses (e.g., "Here is the HTML for the homepage").</li>
          </ul>
          <p class="mt-2"><strong>HTTPS (HTTP Secure)</strong> is the exact same protocol, but with a crucial layer of security added. It uses <strong>SSL/TLS</strong> to encrypt the entire conversation between the client and the server. This prevents attackers from "eavesdropping" or modifying the data being sent, which is essential for login forms, credit card payments, and protecting user privacy.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (Conceptual Flow)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-bash">
# 1. Client (Browser) makes a request:
GET /contact HTTP/1.1
Host: www.example.com

# 2. Server (Node.js) sends a response:
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 127

&lt;html&gt;
  &lt;body&gt;&lt;h1&gt;Contact Us&lt;/h1&gt;&lt;/body&gt;
&lt;/html&gt;

# With HTTPS, this entire conversation is encrypted and unreadable to outsiders.
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>All web development, especially back-end development with Node.js, is based on handling HTTP requests and sending HTTP responses. Understanding this "request/response cycle" is the single most important concept for building APIs or web applications. HTTPS is now the standard; browsers will warn users if a site uses plain HTTP.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>What is SSL/TLS and how does the "handshake" work at a high level?</li>
            <li>What is the 'S' in HTTPS and what does it provide? (Secure: Encryption, Authentication, and Integrity).</li>
            <li>Why would a site still use HTTP? (No good reason for public sites; maybe for local-only development).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview" target="_blank" class="hover:underline">MDN: An overview of HTTP</a></li>
            <li><a href="https://www.cloudflare.com/learning/ssl/what-is-https/" target="_blank" class="hover:underline">Cloudflare: What is HTTPS?</a></li>
            <li><a href="https://www.digitalocean.com/community/tutorials/http-vs-https" target="_blank" class="hover:underline">DigitalOcean: HTTP vs. HTTPS</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "HTTP Request/Response Structure",
    difficulty: "Beginner",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I know that an HTTP message, whether a request or response, has a start-line, headers, and an optional body. For a request, this includes the method and path. For a response, it includes the status code. Headers provide metadata, and the body contains the actual data, like JSON or HTML."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>Every HTTP message is just plain text with three parts.</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong>Start-Line:</strong> The first line.
              <ul>
                <li><strong>Request:</strong> <code>GET /users HTTP/1.1</code> (Method, Path, Version)</li>
                <li><strong>Response:</strong> <code>HTTP/1.1 200 OK</code> (Version, Status Code, Status Message)</li>
              </ul>
            </li>
            <li><strong>Headers:</strong> Key-value pairs providing metadata about the message. Examples:
              <ul>
                <li><code>Host: api.example.com</code> (Which server to talk to)</li>
                <li><code>User-Agent: Mozilla/5.0</code> (Which client is asking)</li>
                <li><code>Content-Type: application/json</code> (What format the body is in)</li>
              </ul>
            </li>
            <li><strong>Body:</strong> (Optional) The actual data being sent. This is used in <code>POST</code> requests (to send data) and most responses (to send the HTML or JSON back).</li>
          </ul>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (A POST Request & Response)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-http">
# --- REQUEST (Client to Server) ---

# Start-Line
POST /api/users HTTP/1.1

# Headers
Host: my-app.com
Content-Type: application/json
Content-Length: 35

# Body (JSON data)
{
  "name": "Alice",
  "job": "Developer"
}

# --- RESPONSE (Server to Client) ---

# Start-Line
HTTP/1.1 201 Created

# Headers
Content-Type: application/json
Date: Mon, 03 Nov 2025 01:30:00 GMT

# Body (New user with ID)
{
  "id": 123,
  "name": "Alice",
  "job": "Developer"
}
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>In Node.js, you are not just "writing a function." You are parsing requests and building responses. You will directly read from <code>request.headers</code>, check <code>request.method</code>, read the <code>request</code> body, and set <code>response.headers</code> (like <code>Content-Type</code>) and <code>response.statusCode</code> before sending the body back.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>What is the <code>Host</code> header used for? (To allow a single server to host multiple websites).</li>
            <li>What is the <code>Content-Length</code> header? (It tells the server how many bytes the body is, so it knows when it's done reading).</li>
            <li>What's the difference between <code>User-Agent</code> and <code>Accept</code> headers? (<code>User-Agent</code> says *who* I am; <code>Accept</code> says *what* formats I understand).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Messages" target="_blank" class="hover:underline">MDN: HTTP Messages</a></li>
            <li><a href="https.developer.mozilla.org/en-US/docs/Web/HTTP/Headers" target="_blank" class="hover:underline">MDN: HTTP Headers</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "HTTP Methods (Basics): GET & POST",
    difficulty: "Beginner",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I know the basic HTTP verbs, especially GET and POST. GET is for retrieving data and should be 'safe' and 'idempotent'‚Äîit doesn't change anything. POST is for submitting new data, like creating a user or posting a form, and it sends its payload in the request body."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>HTTP Methods (or "verbs") tell the server what <strong>action</strong> the client wants to perform on a resource.</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong><code>GET</code>:</strong>
              <ul>
                <li><strong>Action:</strong> Retrieve data.</li>
                <li><strong>Example:</strong> Get a user's profile, get a list of products.</li>
                <li><strong>Data:</strong> Sent in the URL (e.g., <code>/users?id=123</code>).</li>
                <li><strong>Body:</strong> Has no body.</li>
                <li><strong>Safe:</strong> Should not change data on the server.</li>
              </ul>
            </li>
            <li><strong><code>POST</code>:</strong>
              <ul>
                <li><strong>Action:</strong> Submit data to be processed.</li>
                <li><strong>Example:</strong> Create a new user, submit a contact form.</li>
                <li><strong>Data:</strong> Sent in the request <strong>body</strong>.</li>
                <li><strong>Body:</strong> Almost always has a body (e.g., JSON or form data).</li>
                <li><strong>Safe:</strong> Not safe. It is *expected* to change data (e.g., create a new record).</li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (How they are used)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-http">
# --- GET Request ---
# Action: Get the user with ID 42
GET /api/users/42 HTTP/1.1
Host: example.com


# --- POST Request ---
# Action: Create a new user
POST /api/users HTTP/1.1
Host: example.com
Content-Type: application/json

{
  "username": "new_user",
  "email": "new@example.com"
}
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>In your Node.js server, your first step is *always* to check the <code>request.method</code>. If you get a <code>GET</code> request, you'll fetch data from a database. If you get a <code>POST</code> request, you'll parse the request body and save new data. Using the wrong method is confusing and breaks RESTful API design principles.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>What are <code>PUT</code> and <code>DELETE</code> methods for? (<code>PUT</code> to update an entire resource, <code>DELETE</code> to remove one).</li>
            <li>What does "idempotent" mean? (Doing the request once has the same effect as doing it 100 times. <code>GET</code> is idempotent, <code>POST</code> is not).</li>
            <li>How does a browser send a <code>POST</code> request? (Typically from an HTML <code>&lt;form method="POST"&gt;</code>).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods" target="_blank" class="hover:underline">MDN: HTTP request methods</a></li>
            <li><a href="https://www.restapitutorial.com/httpmethods.html" target="_blank" class="hover:underline">REST API Tutorial: HTTP Methods</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "Common Status Codes: 200, 404, 500",
    difficulty: "Beginner",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I know the main status code classes. 2xx for success, like '200 OK'. 4xx for client errors, like '404 Not Found' if a user requests a non-existent page. And 5xx for server errors, like '500 Internal Server Error' if my code crashes while processing the request."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>HTTP Status Codes are a 3-digit number sent by the server to tell the client the <strong>result</strong> of its request. They are grouped into classes:</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong><code>2xx</code> (Success):</strong> The request was successful.
              <ul>
                <li><strong><code>200 OK</code>:</strong> The standard "everything worked" response. Used for <code>GET</code>.</li>
                <li><strong><code>201 Created</code>:</strong> The request was successful and a new resource was created. Used for <code>POST</code>.</li>
              </ul>
            </li>
            <li><strong><code>4xx</code> (Client Error):</strong> The client made a mistake.
              <ul>
                <li><strong><code>404 Not Found</code>:</strong> The server couldn't find the requested resource (e.g., wrong URL).</li>
                <li><strong><code>400 Bad Request</code>:</strong> The server couldn't understand the request, often due to invalid JSON or missing data.</li>
                <li><strong><code>403 Forbidden</code>:</strong> The client is not authorized to access this resource.</li>
              </ul>
            </li>
            <li><strong><code>5xx</code> (Server Error):</strong> The server failed to fulfill a valid request.
              <ul>
                <li><strong><code>500 Internal Server Error</code>:</strong> A generic "something broke" error. Your Node.js code probably crashed.</li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (How a server sends them)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-http">
# --- Response for a successful GET ---
HTTP/1.1 200 OK
Content-Type: application/json

{ "data": "here is your stuff" }


# --- Response for a missing page ---
HTTP/1.1 404 Not Found
Content-Type: application/json

{ "error": "User not found" }


# --- Response for a server crash ---
HTTP/1.1 500 Internal Server Error
Content-Type: application/json

{ "error": "An unexpected error occurred" }
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>Sending the correct status code is critical. Your front-end application (like React or Angular) will check the status code to know if its request worked. If it sees a <code>200</code>, it shows the data. If it sees a <code>404</code>, it shows a "Not Found" message. If it sees a <code>500</code>, it shows a generic "Try again later" error.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>What's the difference between a 401 and a 403? (401 Unauthorized means "you need to log in"; 403 Forbidden means "you are logged in, but you still can't see this").</li>
            <li>What is a 301 or 302? (Redirects. 301 is a permanent redirect, 302 is temporary).</li>
            <li>When would you send a 204? (No Content. For a <code>DELETE</code> request, to say "it worked, but I have nothing to send you back").</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status" target="_blank" class="hover:underline">MDN: HTTP status codes</a></li>
            <li><a href="https://http.cat/" target="_blank" class="hover:underline">HTTP Status Cats (A fun way to learn)</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "Using the `http` module",
    difficulty: "Intermediate",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I'm comfortable using the built-in 'http' module to create a basic server. I know 'http.createServer' takes a callback that runs on every request, and inside that, I can inspect 'req.url' and 'req.method' to build a response, set 'res.writeHead' for status and headers, and use 'res.end' to send the data."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>The <code>http</code> module is a core Node.js library for creating HTTP servers. You don't need any frameworks like Express to use it, though frameworks make it much easier. The primary method is <code>http.createServer()</code>, which creates a server object. You provide a callback function that will be executed <strong>every time</strong> a new request hits the server.</p>
          <p class="mt-2">This callback receives two objects: <code>req</code> (the request) and <code>res</code> (the response).</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (A simple router)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
const http = require('http');

const port = 3000;

// The callback function that handles all requests
const requestHandler = (req, res) => {
  console.log(\`New request: \${req.method} \${req.url}\`);

  // Simple Router
  if (req.method === 'GET' && req.url === '/') {
    // 1. Set Status Code 200 (OK) and Headers
    res.writeHead(200, { 'Content-Type': 'application/json' });
    // 2. Write the body and send
    res.end(JSON.stringify({ message: 'Welcome to the homepage!' }));
  
  } else if (req.method === 'GET' && req.url === '/about') {
    res.writeHead(200, { 'Content-Type': 'text/html' });
    res.end('&lt;h1&gt;About Us&lt;/h1&gt;');
  
  } else if (req.method === 'POST' && req.url === '/api/submit') {
    // Handling a POST request (body parsing is more complex)
    res.writeHead(201, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ message: 'Data submitted' }));
  
  } else {
    // 404 Not Found for everything else
    res.writeHead(404, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ error: 'Page Not Found' }));
  }
};

// Create the server
const server = http.createServer(requestHandler);

// Start listening
server.listen(port, () => {
  console.log(\`Server is listening on http://localhost:\${port}\`);
});
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Terminal Commands</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-bash">
# Save the code as server.js
$ node server.js
# Output: Server is listening on http://localhost:3000

# In another terminal, test with curl:
$ curl http://localhost:3000/
# {"message":"Welcome to the homepage!"}

$ curl http://localhost:3000/about
# <h1>About Us</h1>

$ curl -X POST http://localhost:3000/api/submit
# {"message":"Data submitted"}

$ curl http://localhost:3000/bad-url
# {"error":"Page Not Found"}
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>This is the "raw" material of a Node.js web server. While you will almost always use a framework like <strong>Express.js</strong> (which does all the routing and parsing for you), Express is built on *top* of this <code>http</code> module. Understanding what happens under the hood makes you a much stronger developer.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>How would you parse the body of a POST request? (It's complex: you have to listen for 'data' and 'end' events on the <code>req</code> object, which is a stream).</li>
            <li>Why is it better to use Express than this? (Express handles routing, body parsing,
            error handling, and middleware, which is very complex to do manually).</li>
            <li>What does <code>res.end()</code> do? (It finalizes the response, sends all data, and tells the server the request is complete).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://nodejs.org/api/http.html" target="_blank" class="hover:underline">Node.js Docs: HTTP</a></li>
            <li><a href="https://developer.mozilla.org/en-US/docs/learn/Server-side/Nodejs/skeleton_server" target="_blank" class="hover:underline">MDN: Create a Node.js HTTP server</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "REST API Principles",
    difficulty: "Intermediate",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I design my APIs using REST principles. This means I structure my endpoints around resources (like '/users' or '/products'), and I use the standard HTTP methods (like GET, POST, PUT, DELETE) to represent actions on those resources, rather than using custom verbs in my URLs."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p><strong>REST (REpresentational State Transfer)</strong> is an architectural style for designing networked applications. It's not a strict protocol, but a set of guidelines for building clean, scalable, and easy-to-understand web APIs.</p>
          <p class="mt-2">Key Principles:</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong>Resources (Nouns, not Verbs):</strong> Endpoints are centered around "resources" (objects or entities).
              <ul>
                <li><strong>Good:</strong> <code>/users</code>, <code>/products/123</code></li>
                <li><strong>Bad:</strong> <code>/getAllUsers</code>, <code>/createNewProduct</code>, <code>/updateProductById</code></li>
              </ul>
            </li>
            <li><strong>Use HTTP Methods (Verbs):</strong> The *action* you want to perform is defined by the HTTP method, not the URL.</li>
            <li><strong>Stateless:</strong> Every request from a client must contain all the information needed to process it (e.g., an auth token). The server does not store "session state" for the client.</li>
          </ul>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (A "RESTful" API design)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
// A RESTful design for a "users" resource

// GET /api/users
// (Read) Get a list of all users
app.get('/api/users', (req, res) => { /* ... */ });

// POST /api/users
// (Create) Create a new user (data in req.body)
app.post('/api/users', (req, res) => { /* ... */ });


// GET /api/users/:id
// (Read) Get a single user by their ID
app.get('/api/users/:id', (req, res) => { /* ... */ });

// PUT /api/users/:id
// (Update/Replace) Replace the entire user with ID
app.put('/api/users/:id', (req, res) => { /* ... */ });

// PATCH /api/users/:id
// (Update/Modify) Partially update the user with ID
app.patch('/api/users/:id', (req, res) => { /* ... */ });

// DELETE /api/users/:id
// (Delete) Delete the user with ID
app.delete('/api/users/:id', (req, res) => { /* ... */ });
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>REST is the industry standard. Following it makes your API predictable, scalable, and easy for other developers (including your front-end team) to understand and use. A well-designed REST API is self-explanatory.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>What does "stateless" mean for your server? (It means you don't store user info in memory between requests. If you need to know *who* a user is, they must send a token (e.g., JWT) with *every* request).</li>
            <li>How would you get all comments for a specific post? (Nested resource: <code>GET /api/posts/:postId/comments</code>).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://developer.mozilla.org/en-US/docs/Glossary/REST" target="_blank" class="hover:underline">MDN: REST</a></li>
            <li><a href="https://aws.amazon.com/what-is/restful-api/" target="_blank" class="hover:underline">What is a RESTful API? (AWS)</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "HTTP Methods (Full)",
    difficulty: "Intermediate",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I know the main HTTP verbs and their RESTful meaning: 'GET' to retrieve data, 'POST' to create a new resource, 'PUT' to replace a resource, 'PATCH' to partially update, and 'DELETE' to remove a resource. I also know 'OPTIONS' is used for CORS preflights."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>HTTP methods (or "verbs") define the *action* to be performed on a resource.</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong><code>GET</code>:</strong> (Read) Retrieve a resource. Safe and idempotent.</li>
            <li><strong><code>POST</code>:</strong> (Create) Submit a new resource (e.g., create a new user). Not idempotent.</li>
            <li><strong><code>PUT</code>:</strong> (Replace) Replace an existing resource *entirely* with new data. Idempotent.</li>
            <li><strong><code>PATCH</code>:</strong> (Modify) Apply a *partial* update to a resource (e.g., update only the 'email' field). Not always idempotent.</li>
            <li><strong><code>DELETE</code>:</strong> (Delete) Delete a resource. Idempotent.</li>
            <li><strong><code>OPTIONS</code>:</strong> Asks the server what methods and headers are allowed for a URL. Used by browsers for "preflight" requests in CORS.</li>
            <li><strong><code>HEAD</code>:</strong> Same as <code>GET</code>, but returns *only* the headers, with no response body. Used to check if a resource exists or get its size.</li>
          </ul>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (Express routes for each)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
// GET /items/1
app.get('/items/:id', (req, res) => {
  res.send(\`Get item \${req.params.id}\`);
});

// POST /items
app.post('/items', (req, res) => {
  res.status(201).send('Create new item');
});

// PUT /items/1
app.put('/items/:id', (req, res) => {
  res.send(\`Replace item \${req.params.id}\`);
});

// PATCH /items/1
app.patch('/items/:id', (req, res) => {
  res.send(\`Partially update item \${req.params.id}\`);
});

// DELETE /items/1
app.delete('/items/:id', (req, res) => {
  res.send(\`Delete item \${req.params.id}\`);
});

// OPTIONS /items/1
app.options('/items/:id', (req, res) => {
  res.setHeader('Allow', 'GET, PUT, PATCH, DELETE, OPTIONS');
  res.send();
});

// HEAD /items/1
app.head('/items/:id', (req, res) => {
  // Logic to get resource metadata
  res.setHeader('Content-Length', '1234'); // Example header
  res.end(); // Send no body
});
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>Using the correct HTTP method is the most important part of building a semantic, predictable REST API. It allows clients (like browsers or mobile apps) to know exactly what to expect from an endpoint just by looking at the method and URL.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>What is the difference between <code>PUT</code> and <code>PATCH</code>? (This is its own topic, but: PUT replaces the *entire* resource, PATCH applies a *partial* change).</li>
            <li>When would <code>HEAD</code> be used? (To check a file's size before downloading it, or to check if a link is broken without downloading the whole page).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods" target="_blank" class="hover:underline">MDN: HTTP request methods</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "Idempotency: `PUT` vs. `POST` vs. `PATCH`",
    difficulty: "Advanced",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I understand idempotency is whether an operation can be run multiple times with the same result. 'PUT' is idempotent because 'PUT /user/1 {name: "A"}' twice is the same as once. 'POST' is not: 'POST /users' twice creates two users. 'PATCH' is generally not idempotent, as a command like 'add 1 to age' would fail."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>An operation is <strong>idempotent</strong> if running it one time has the same effect as running it 100 times.</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong><code>POST /users</code> (Create User)</strong>
              <ul>
                <li><strong>Not Idempotent.</strong> Every call creates a new user. Calling it 3 times results in 3 new users.</li>
              </ul>
            </li>
            <li><strong><code>PUT /users/123</code> (Replace User 123)</strong>
              <ul>
                <li><strong>Idempotent.</strong> The request says "make user 123 look *exactly* like this." The first call sets the user's data. The 2nd, 3rd, and 100th calls set the user to that *same* data. The end result is identical.</li>
              </ul>
            </li>
            <li><strong><code>PATCH /users/123</code> (Modify User 123)</strong>
              <ul>
                <li><strong>Not Idempotent (Usually).</strong> This is the tricky one. If your patch is "set email to 'a@b.com'", it's idempotent. But if your patch is "add 10 to user's score," it is *not* idempotent. Because it's not guaranteed, it's treated as non-idempotent.</li>
              </ul>
            </li>
            <li><strong><code>GET</code>, <code>HEAD</code>, <code>DELETE</code></strong> are all idempotent. (Deleting something that's already deleted still results in it being deleted).</li>
          </ul>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (Conceptual Code)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
let users = { '123': { name: 'Alex', age: 30 } };

// POST: Not Idempotent
app.post('/users', (req, res) => {
  const newUser = { id: Math.random(), ...req.body };
  users[newUser.id] = newUser;
  // Running this twice creates two different users.
  res.status(201).json(newUser);
});

// PUT: Idempotent
app.put('/users/:id', (req, res) => {
  // This request *replaces* the entire resource
  users[req.params.id] = { ...req.body };
  // Running this twice with the same req.body just
  // results in the same final state.
  res.json(users[req.params.id]);
});

// PATCH: Not Idempotent (Example)
app.patch('/users/:id/age', (req, res) => {
  // This patch *modifies* based on current state
  users[req.params.id].age += 1;
  // Running this twice results in (age + 2),
  // which is different from running it once (age + 1).
  res.json(users[req.params.id]);
});
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>Idempotency is important for network reliability. If a client sends a <code>PUT</code> request and the network times out, it doesn't know if the request worked. It can safely send it again. If it was a <code>POST</code> and it retried, it might accidentally create two resources. This distinction is crucial for robust API design.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>Why is <code>DELETE</code> idempotent? (Because the goal is "resource must not exist." After the first call, it's gone. The 2nd call also results in "resource does not exist." The end state is the same).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://developer.mozilla.org/en-US/docs/Glossary/Idempotent" target="_blank" class="hover:underline">MDN: Idempotent</a></li>
            <li><a href="https://restfulapi.net/http-methods/#idempotent-methods" target="_blank" class="hover:underline">Idempotent Methods (restfulapi.net)</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "HTTP Headers (Common)",
    difficulty: "Intermediate",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I know headers are key-value metadata. On the request, I look for 'Content-Type' to know how to parse 'req.body', and 'Authorization' (like 'Bearer token...') to check credentials. On the response, I use 'res.set()' to set headers, and I know 'res.json()' automatically sets 'Content-Type: application/json'."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>HTTP Headers are key-value pairs of metadata sent with every request and response. They provide context and instructions to the client and server.</p>
          <p class="mt-2"><strong>Common Request Headers:</strong> (Sent by client)</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong><code>Content-Type</code>:</strong> What kind of data is in the body (e.g., <code>application/json</code>, <code>application/x-www-form-urlencoded</code>).</li>
            <li><strong><code>Authorization</code>:</strong> How the client is authenticating (e.g., <code>Bearer eyJhbGci...</code>).</li>
            <li><strong><code>Accept</code>:</strong> What kind of response format the client wants (e.g., <code>application/json</code>).</li>
            <li><strong><code>User-Agent</code>:</strong> Information about the client (e.g., browser, cURL).</li>
          </ul>
          <p class="mt-2"><strong>Common Response Headers:</strong> (Sent by server)</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong><code>Content-Type</code>:</strong> What kind of data is in the response body (e.g., <code>application/json</code>, <code>text/html</code>).</li>
            <li><strong><code>Content-Length</code>:</strong> The size of the response body in bytes.</li>
            <li><strong><code>Location</code>:</strong> Used in redirects (<code>3xx</code> status) to tell the client where to go.</li>
            <li><strong><code>Set-Cookie</code>:</strong> Instructs the client to set a cookie.</li>
          </ul>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (Reading and Setting Headers)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
const express = require('express');
const app = express();

app.post('/api/auth-check', (req, res) => {
  // 1. Read request headers
  // Use req.get() (case-insensitive) or req.headers[]
  const contentType = req.get('Content-Type');
  const authHeader = req.get('Authorization'); // e.g., "Bearer mytoken123"

  if (contentType !== 'application/json') {
    return res.status(400).send('Must be application/json');
  }
  
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).send('Missing Bearer token');
  }

  // 2. Set response headers
  // Express does this for you with res.json(), but
  // you can set custom ones with res.set()
  res.set('X-Custom-Header', 'Hello from my server');
  
  res.json({ message: 'You are authenticated' });
});
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>Headers are the "language" of HTTP. You can't handle a <code>POST</code> request without reading <code>Content-Type</code>. You can't implement authentication without reading <code>Authorization</code>. You can't do redirects without setting <code>Location</code>. They are fundamental to the web.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>What's the difference between <code>req.get('Content-Type')</code> and <code>req.headers['content-type']</code>? (<code>req.get()</code> is case-insensitive, which is safer. <code>req.headers</code> is the raw object where keys are lowercase).</li>
            <li>What's a "preflight" request? (An <code>OPTIONS</code> request the browser sends before a <code>POST</code>/<code>PUT</code> to a different domain, to check CORS permissions).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers" target="_blank" class="hover:underline">MDN: HTTP Headers</a></li>
            <li><a href="https://expressjs.com/en/4x/api.html#req.get" target="_blank" class="hover:underline">Express Docs: req.get()</a></li>
            <li><a href="https://expressjs.com/en/4x/api.html#res.set" target="_blank" class="hover:underline">Express Docs: res.set()</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "Setting Headers/Status: `setHeader()` vs. `writeHead()`",
    difficulty: "Advanced",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I know 'writeHead()' and 'setHeader()' are from the low-level Node 'http' module. 'writeHead' sends the status and all headers in one go. In Express, I don't use these. I use the 'res.status()' and 'res.set()' methods, which are Express's chainable, user-friendly abstractions."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>This distinction is about the <strong>low-level Node.js <code>http</code> module</strong> versus the <strong>Express framework abstraction</strong>.</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong>Node.js <code>http</code> Module (Low-level):</strong>
              <ul>
                <li><strong><code>res.writeHead(statusCode, headers)</code>:</strong> Writes the status code AND all headers at once. You can't set more headers after this.</li>
                <li><strong><code>res.setHeader(name, value)</code>:</strong> Sets a single header. You can call this multiple times, but *before* <code>writeHead</code> or writing the body.</li>
              </ul>
            </li>
            <li><strong>Express <code>res</code> object (High-level):</strong>
              <ul>
                <li><strong><code>res.status(code)</code>:</strong> Sets the status code. It's chainable.</li>
                <li><strong><code>res.set(name, value)</code>:</strong> Sets a single header. It's chainable.</li>
                <li>Express handles "when" to send the headers for you. You just declare the status and headers, and when you call <code>.send()</code> or <code>.json()</code>, Express sends them.</li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (Node.js vs. Express)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
// --- 1. Low-level Node.js http server ---
const http = require('http');
const server = http.createServer((req, res) => {
  // We have to set headers and status manually
  res.setHeader('Content-Type', 'application/json');
  res.setHeader('X-Powered-By', 'Node');
  res.writeHead(200); // Sends status and all headers
  
  res.end(JSON.stringify({ message: 'Hello' }));
});

// --- 2. The Express Way (Much cleaner) ---
const express = require('express');
const app = express();

app.get('/', (req, res) => {
  // Just chain methods. Express handles the rest.
  res
    .status(200)
    .set('X-Powered-By', 'Express')
    .json({ message: 'Hello' }); // .json() also sets Content-Type
});
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>This shows you understand the layers of abstraction. While you will (and should) use the Express methods 99% of the time, knowing that <code>res</code> in Express is just an enhanced version of Node's <code>http.ServerResponse</code> object is key. It demystifies what Express is actually doing for you.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>What happens if you try to <code>res.set()</code> after <code>res.json()</code>? (It won't work, and you'll get an error: "Cannot set headers after they are sent to the client." <code>res.json()</code> sends the response).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://nodejs.org/api/http.html#reswriteheadstatuscode-statusmessage-headers" target="_blank" class="hover:underline">Node.js Docs: res.writeHead()</a></li>
            <li><a href="https://nodejs.org/api/http.html#ressetheadername-value" target="_blank" class="hover:underline">Node.js Docs: res.setHeader()</a></li>
            <li><a href="https://expressjs.com/en/4x/api.html#res.status" target="_blank" class="hover:underline">Express Docs: res.status()</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "Common Status Codes (Fuller)",
    difficulty: "Beginner",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I know the main status code categories. 2xx for success, like '201 Created' after a POST. 4xx for client errors, like '400 Bad Request' for bad data, '401 Unauthorized' for no auth, or '403 Forbidden' for no permission. And 5xx for server errors."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>Status codes are the server's way of telling the client the result of its request.</p>
          <p class="mt-2"><strong>2xx Success:</strong></p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong><code>200 OK</code>:</strong> Standard success (e.g., <code>GET</code>, <code>PUT</code>, <code>PATCH</code>).</li>
            <li><strong><code>201 Created</code>:</strong> A new resource was successfully created (e.g., after a <code>POST</code>).</li>
            <li><strong><code>204 No Content</code>:</strong> Success, but there is no body to send back (e.g., after a <code>DELETE</code>).</li>
          </ul>
          <p class="mt-2"><strong>4xx Client Error:</strong> (The client did something wrong)</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong><code>400 Bad Request</code>:</strong> Server can't process the request (e.g., missing data, invalid JSON).</li>
            <li><strong><code>401 Unauthorized</code>:</strong> Client is not authenticated. They need to log in / send a valid token.</li>
            <li><strong><code>403 Forbidden</code>:</strong> Client is authenticated, but does not have *permission* to do this (e.g., a non-admin trying to access an admin panel).</li>
            <li><strong><code>404 Not Found</code>:</strong> The requested resource does not exist.</li>
          </ul>
          <p class="mt-2"><strong>5xx Server Error:</strong> (The server did something wrong)</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong><code>500 Internal Server Error</code>:</strong> A generic "catch-all" error. Your app crashed.</li>
          </ul>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (Express routes for each)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
// 201 Created
app.post('/users', (req, res) => {
  const newUser = { id: 1, ...req.body };
  res.status(201).json(newUser);
});

// 400 Bad Request
app.post('/users', (req, res) => {
  if (!req.body.name) {
    res.status(400).json({ error: 'Name is required' });
  }
});

// 401 Unauthorized vs. 403 Forbidden
app.get('/admin', (req, res) => {
  if (!req.user) {
    // They aren't logged in at all
    res.status(401).json({ error: 'You must be logged in' });
  } else if (req.user.role !== 'admin') {
    // They are logged in, but are not an admin
    res.status(403).json({ error: 'You do not have permission' });
  } else {
    res.json({ message: 'Welcome, Admin' });
  }
});

// 500 Internal Server Error
app.get('/danger', (req, res) => {
  try {
    throw new Error('Something broke!');
  } catch (err) {
    res.status(500).json({ error: 'Internal Server Error' });
  }
});
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>Your front-end application *depends* on these codes. The front-end code will literally be: <code>if (response.status === 201) { ... } else if (response.status === 400) { ... }</code>. Using the correct, specific code is the foundation of a good API.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>What is the crucial difference between 401 and 403? (401 means "Who are you?". 403 means "I know who you are, and you're not allowed.").</li>
            <li>What's a good response for a <code>DELETE</code> request? (<code>204 No Content</code>, or <code>200 OK</code> with the deleted item).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status" target="_blank" class="hover:underline">MDN: HTTP status codes</a></li>
          </ul>
        </section>
      </div>
    `
  },

  {
    type: 'heading',
    title: "Express JS",
  },
  {
    title: "What is Express.js?",
    difficulty: "Beginner",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "Express.js is a minimal and flexible Node.js web application framework. I use it because it simplifies core Node.js tasks like routing, handling requests, and managing middleware, making server-side code much cleaner and faster to write."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>Express.js is a back-end web framework for Node.js. It is the most popular and "de-facto" standard framework for building servers with Node.</p>
          <p class="mt-2">It's <strong>not</strong> a "framework" like Angular or Ruby on Rails that forces a strict project structure. Instead, it's a minimal and "unopinionated" library that provides a powerful set of tools on top of the built-in <code>http</code> module, letting you build your server however you like.</p>
          <p class="mt-2"><strong>Why use it?</strong> It dramatically simplifies tasks that are complex with the raw <code>http</code> module:</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong>Routing:</strong> Easily handle different URLs and HTTP methods (<code>app.get</code>, <code>app.post</code>).</li>
            <li><strong>Request/Response Helpers:</strong> Provides easy-to-use <code>req</code> and <code>res</code> objects (e.g., <code>res.json()</code>, <code>req.params</code>).</li>
            <li><strong>Middleware:</strong> A powerful concept for adding features like logging, authentication, and body-parsing.</li>
            <li><strong>Error Handling:</strong> A centralized place to catch and handle errors.</li>
          </ul>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example: Before (raw Node.js) vs. After (Express)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
// --- BEFORE: Raw Node.js http module ---
const http = require('http');
http.createServer((req, res) => {
  if (req.method === 'GET' && req.url === '/') {
    res.writeHead(200, { 'Content-Type': 'text/plain' });
    res.end('Hello World');
  } else {
    res.writeHead(404, { 'Content-Type': 'text/plain' });
    res.end('Not Found');
  }
}).listen(3000);


// --- AFTER: With Express.js ---
const express = require('express');
const app = express();

app.get('/', (req, res) => {
  res.send('Hello World');
});

// 404s are handled automatically by default
app.listen(3000, () => console.log('Server running'));

// Note how much cleaner and more readable the Express version is.
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>You will almost never use the raw <code>http</code> module for a real project. Express (or a similar framework like Fastify or Koa) is the standard. It provides the essential structure and tools, allowing you to focus on your application's logic instead of re-inventing the "server" part every time.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>What is "middleware"?</li>
            <li>Is Express a framework or a library? (It's often debated, but it's a "web application framework" by its own definition, just an unopinionated one).</li>
            <li>What are some alternatives to Express? (e.g., Koa, Fastify, Hapi).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://expressjs.com/" target="_blank" class="hover:underline">Express.js Official Website</a></li>
            <li><a href="https://developer.mozilla.org/en-US/docs/Learn/Server-side/Express_Nodejs/Introduction" target="_blank" class="hover:underline">MDN: Introduction to Express/Node.js</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "Installing Express",
    difficulty: "Beginner",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I install Express like any other npm package: 'npm install express'. This adds it to my 'package.json' as a production dependency, which is correct because my server needs it to run."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>Express is just a package on the npm registry. To use it, you must first initialize a Node.js project (which creates a <code>package.json</code> file) and then install <code>express</code> as a dependency. This will download the Express code into your <code>node_modules</code> folder.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Terminal Commands</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-bash">
# 1. Create a new project directory
$ mkdir my-express-server
$ cd my-express-server

# 2. Initialize a new Node.js project (creates package.json)
$ npm init -y

# 3. Install Express
$ npm install express

# You can also use the shorthand 'npm i express'
            </code></pre>
          </div>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (Resulting package.json)</h2>
          <p class="mb-2">After running <code>npm install express</code>, your <code>package.json</code> will be updated with a <code>dependencies</code> section.</p>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-json">
{
  "name": "my-express-server",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "express": "^4.18.2"
  }
}
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>This is the first physical step to building any Express application. Understanding that Express is just an npm package, like any other, is a key first step. It lives in <code>node_modules</code> and is managed by <code>package.json</code>.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>Why is Express in <code>dependencies</code> and not <code>devDependencies</code>? (Because the server needs Express to *run* in production, not just for development).</li>
            <li>How would you install a specific version of Express? (<code>npm install express@4.17.1</code>).</li>
            <li>What does the <code>^</code> in <code>^4.18.2</code> mean? (It's for semantic versioning, allowing minor and patch updates).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://expressjs.com/en/starter/installing.html" target="_blank" class="hover:underline">Express Docs: Installing</a></li>
            <li><a href="https://docs.npmjs.com/cli/v10/commands/npm-install" target="_blank" class="hover:underline">NPM Docs: npm install</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "Creating an Express Server: `express()`, `app.listen()`",
    difficulty: "Beginner",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "To create a basic server, I first require 'express'. Then I call 'express()' to create an application instance, which I conventionally name 'app'. After defining my routes on 'app', I call 'app.listen()' at the end, passing it a port number and a callback to log that the server is running."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>This is the "Hello World" of Express. It's a three-step process:</p>
          <ol class="list-decimal list-inside ml-4 mt-2 space-y-1">
            <li><strong>Import:</strong> Use <code>require('express')</code> to get the Express function.</li>
            <li><strong>Initialize:</strong> Call <code>express()</code>. This creates your main <code>app</code> object, which you will use to define all your routes and middleware.</li>
            <li><strong>Listen:</strong> Call <code>app.listen(port, ...)</code>. This starts the server, binds it to a specific port, and listens for incoming connections.</li>
          </ol>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (The smallest Express server)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
// 1. Import
const express = require('express');

// 2. Initialize
const app = express();
const port = 3000;

// Define a simple route (we'll cover this next)
app.get('/', (req, res) => {
  res.send('Hello, Express!');
});

// 3. Listen
app.listen(port, () => {
  // This callback runs once the server is successfully started
  console.log(\`Server running at http://localhost:\${port}\`);
});
            </code></pre>
          </div>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Terminal Commands</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-bash">
# Save the code as index.js (or server.js)
$ node index.js
# Output: Server running at http://localhost:3000

# Open http://localhost:3000 in your browser
# You will see "Hello, Express!"
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>These three steps are the boilerplate for <em>every</em> Express application you will ever build. Understanding that <code>app</code> is your central object and <code>app.listen</code> is what "turns on" the server is fundamental.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>What is the <code>app</code> object? (An object with methods for routing, middleware, etc.)</li>
            <li>What does <code>app.listen()</code> do that <code>http.createServer()</code> doesn't? (Actually, <code>app.listen</code> creates an <code>http</code> server for you under the hood!)</li>
            <li>What is <code>process.env.PORT</code>? (A common pattern for using a port from an environment variable, e.g., <code>const port = process.env.PORT || 3000;</code>).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://expressjs.com/en/starter/hello-world.html" target="_blank" class="hover:underline">Express Docs: Hello world</a></li>
            <li><a href="https://expressjs.com/en/4x/api.html#app.listen" target="_blank" class="hover:underline">Express Docs: app.listen()</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "Basic Routing: `app.get()`, `app.post()`",
    difficulty: "Beginner",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I define routes using methods on the 'app' object that match the HTTP verbs, like 'app.get()' or 'app.post()'. Each method takes two main arguments: a string for the URL path, and a callback function (the handler) that receives the 'req' and 'res' objects."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>Routing is how your server responds to different URLs. Express provides methods on the <code>app</code> object that match all HTTP verbs: <code>app.get()</code>, <code>app.post()</code>, <code>app.put()</code>, <code>app.delete()</code>, etc.</p>
          <p class="mt-2">The structure is: <code>app.METHOD(PATH, HANDLER)</code></p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong>METHOD:</strong> <code>get</code>, <code>post</code>, etc.</li>
            <li><strong>PATH:</strong> The URL path string (e.g., <code>'/'</code>, <code>'/users'</code>).</li>
            <li><strong>HANDLER:</strong> A callback function, <code>(req, res) => { ... }</code>, that runs when a request matches the method and path.</li>
          </ul>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (A simple set of routes)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
const express = require('express');
const app = express();
const port = 3000;

// GET request to the homepage
app.get('/', (req, res) => {
  res.send('Welcome to the homepage!');
});

// GET request to /about
app.get('/about', (req, res) => {
  res.send('This is the About Us page.');
});

// POST request to /api/users
// (Note: To read the body, you'd need middleware like express.json())
app.post('/api/users', (req, res) => {
  // For now, just confirm the request
  res.status(201).send('User created successfully!');
});

app.listen(port, () => {
  console.log(\`Server running at http://localhost:\${port}\`);
});
            </code></pre>
          </div>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Terminal Commands</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-bash">
# Run the server
$ node index.js

# Test GET routes in another terminal
$ curl http://localhost:3000/
# Welcome to the homepage!
$ curl http://localhost:3000/about
# This is the About Us page.

# Test POST route
$ curl -X POST http://localhost:3000/api/users
# User created successfully!
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>This is the core of your application. Your entire API or website is just a collection of these routes. <code>app.get</code> and <code>app.post</code> are the two you will use more than any others.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>How would you handle a <code>PUT</code> or <code>DELETE</code> request? (The same way: <code>app.put(...)</code>, <code>app.delete(...)</code>).</li>
            <li>What does <code>app.use()</code> do? (It's used for middleware, or to handle all methods for a path).</li>
            <li>How can you send back JSON data? (<code>res.json({ key: 'value' })</code>).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://expressjs.com/en/starter/basic-routing.html" target="_blank" class="hover:underline">Express Docs: Basic Routing</a></li>
            <li><a href="https://expressjs.com/en/guide/routing.html" target="_blank" class="hover:underline">Express Docs: Routing Guide (Advanced)</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "`req` and `res` objects",
    difficulty: "Beginner",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I know the 'req' and 'res' objects in Express are enhanced versions of the Node 'http' objects. I use 'req' to get request data (like 'req.body', 'req.params', 'req.query') and 'res' to send the response back (using 'res.send()', 'res.json()', or 'res.status()')."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>In every Express route handler, you get two objects: <code>req</code> (Request) and <code>res</code> (Response).</p>
          <p class="mt-2"><strong><code>req</code> (Request Object):</strong></p>
          <p>This object holds all information about the incoming request. Common properties you'll use:</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong><code>req.params</code>:</strong> For route parameters (e.g., <code>/users/:id</code>).</li>
            <li><strong><code>req.query</code>:</strong> For query parameters (e.g., <code>/search?q=test</code>).</li>
            <li><strong><code>req.body</code>:</strong> For data in the request body (e.g., from a POST form). Requires middleware like <code>express.json()</code>.</li>
            <li><strong><code>req.headers</code>:</strong> An object with all request headers.</li>
          </ul>
          <p class="mt-2"><strong><code>res</code> (Response Object):</strong></p>
          <p>This object is what you use to build and send the response back to the client. Common methods you'll use:</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong><code>res.send()</code>:</strong> Sends a response. Can send strings, HTML, or even JSON (it auto-detects).</li>
            <li><strong><code>res.json()</code>:</strong> Sends a JSON response and automatically sets the <code>Content-Type</code> header to <code>application/json</code>.</li>
            <li><strong><code>res.status()</code>:</strong> Sets the HTTP status code (e.g., <code>res.status(404)</code>). It's chainable: <code>res.status(200).json(...)</code>.</li>
            <li><strong><code>res.sendStatus()</code>:</strong> Sets the status and sends a plain text-body of the status (e.g., <code>res.sendStatus(404)</code> sends "Not Found").</li>
          </ul>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (Using req and res)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
const express = require('express');
const app = express();

// A route that sends simple HTML
app.get('/', (req, res) => {
  // Using res.send()
  res.send('&lt;h1&gt;Hello World!&lt;/h1&gt;');
});

// A route that sends JSON
app.get('/api/me', (req, res) => {
  // Using res.json()
  res.json({ name: 'Alice', role: 'developer' });
});

// A route that uses a status code
app.get('/not-found', (req, res) => {
  // Using res.status() and res.send()
  res.status(404).send('Sorry, we cant find that!');
});
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>These two objects are your entire world inside a route handler. 99% of your server-side logic will be: 1. Read data from <code>req</code>. 2. Process it. 3. Send a response using <code>res</code>. Mastering these helpers (especially <code>res.json</code> and <code>res.status</code>) is what makes Express so fast to work with.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>What's the difference between <code>res.send()</code> and <code>res.json()</code>? (<code>res.json</code> *always* sends JSON and sets the correct header. <code>res.send</code> is more flexible but <code>res.json</code> is preferred for APIs).</li>
            <li>What's the difference between <code>res.end()</code> and <code>res.send()</code>? (<code>res.end</code> is a lower-level Node.js method. You should always use <code>res.send</code> or <code>res.json</code> in Express).</li>
            <li>How do you set a response header? (<code>res.set('X-My-Header', 'my-value')</code>).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://expressjs.com/en/4x/api.html#req" target="_blank" class="hover:underline">Express Docs: req (Request)</a></li>
            <li><a href="https://expressjs.com/en/4x/api.html#res" target="_blank" class="hover:underline">Express Docs: res (Response)</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "Query Parameters vs. Path Parameters",
    difficulty: "Intermediate",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I use path parameters, accessed via 'req.params', for required values that define the resource, like '/users/:id'. I use query parameters, from 'req.query', for optional values like sorting or filtering, such as '/products?category=books'."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>These are the two main ways to send dynamic data to your server in a <code>GET</code> request.</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong>Path Parameters (<code>req.params</code>):</strong>
              <ul>
                <li><strong>What:</strong> Part of the URL path itself, defined with a <code>:</code>.</li>
                <li><strong>Example URL:</strong> <code>/users/123</code> or <code>/posts/my-first-post</code></li>
                <li><strong>Route definition:</strong> <code>app.get('/users/:id', ...)</code></li>
                <li><strong>Access:</strong> <code>req.params.id</code> (which would be <code>"123"</code>)</li>
                <li><strong>Use Case:</strong> For <strong>required</strong> identifiers of a resource. You *must* have an ID to get a user.</li>
              </ul>
            </li>
            <li><strong>Query Parameters (<code>req.query</code>):</strong>
              <ul>
                <li><strong>What:</strong> Key-value pairs after a <code>?</code> in the URL.</li>
                <li><strong>Example URL:</strong> <code>/search?q=node&page=2</code></li>
                <li><strong>Route definition:</strong> <code>app.get('/search', ...)</code> (no <code>?</code> needed)</li>
                <li><strong>Access:</strong> <code>req.query.q</code> (<code>"node"</code>) and <code>req.query.page</code> (<code>"2"</code>)</li>
                <li><strong>Use Case:</strong> For <strong>optional</strong> values, like filters, sorting, or pagination.</li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (Using both)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
const express = require('express');
const app = express();

// 1. Using req.params (Path Parameters)
// To get a specific post from a specific user
app.get('/users/:userId/posts/:postId', (req, res) => {
  const { userId, postId } = req.params;
  res.send(\`Fetching post \${postId} for user \${userId}\`);
});

// 2. Using req.query (Query Parameters)
// To search for products
app.get('/products', (req, res) => {
  const { category, limit } = req.query;
  let response = 'Fetching all products';
  if (category) {
    response += \` in category: \${category}\`;
  }
  if (limit) {
    response += \` (limited to \${limit} results)\`;
  }
  res.send(response);
});

app.listen(3000, () => console.log('Server running'));
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Terminal Commands</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-bash">
# Test req.params
$ curl http://localhost:3000/users/alice/posts/42
# Fetching post 42 for user alice

# Test req.query
$ curl "http://localhost:3000/products?category=laptops&limit=10"
# Fetching all products in category: laptops (limited to 10 results)
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>Using these correctly is key to designing a clean, RESTful API. The URL structure should be predictable. Path parameters identify the *resource* (<code>/users/123</code>), and query parameters *filter* or *modify* the representation of that resource (<code>/users/123?view=full</code>).</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>Where does <code>req.body</code> come from? (From <code>POST</code> or <code>PUT</code> requests, in the request body, not the URL).</li>
            <li>What happens if a query parameter is missing? (<code>req.query.missing</code> will just be <code>undefined</code>).</li>
            <li>Are parameters always strings? (Yes, Express parses them as strings. You must <code>parseInt()</code> if you need a number).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://expressjs.com/en/4x/api.html#req.params" target="_blank" class="hover:underline">Express Docs: req.params</a></li>
            <li><a href="https://expressjs.com/en/4x/api.html#req.query" target="_blank" class="hover:underline">Express Docs: req.query</a></li>
            <li><a href="https://www.freecodecamp.org/news/rest-api-design-best-practices-build-a-rest-api/" target="_blank" class="hover:underline">REST API Design (see URL structure)</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "Dynamic Routing",
    difficulty: "Intermediate",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I implement dynamic routing using path parameters, like '/posts/:postId'. This lets me define a single route handler that can manage requests for many different resources (like individual posts) by using the value of ':postId' from 'req.params' to fetch the correct data from a database."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p><strong>Dynamic Routing</strong> is the concept of creating routes that can respond to a variable (or "dynamic") part of the URL, instead of just a static, hard-coded path. You accomplish this using <strong>path parameters</strong> (which you just learned about!).</p>
          <p class="mt-2">Instead of defining a route for every user:</p>
          <pre class="bg-gray-800 text-sm p-2 rounded text-gray-400"><code>
app.get('/users/alice', ...);
app.get('/users/bob', ...);
app.get('/users/charlie', ...);
          </code></pre>
          <p class="mt-2">You define <strong>one</strong> dynamic route:</p>
          <pre class="bg-gray-800 text-sm p-2 rounded text-white"><code>
app.get('/users/:username', ...);
          </code></pre>
          <p class="mt-2">Inside the handler, <code>req.params.username</code> will be <code>"alice"</code>, <code>"bob"</code>, etc. You can then use this variable to look up the user in a database.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (A simple blog)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
const express = require('express');
const app = express();

// A "fake" database of blog posts
const posts = {
  '1': { title: 'First Post', body: 'This is post 1.' },
  '2': { title: 'Second Post', body: 'This is post 2.' },
  'my-third-post': { title: 'Third Post', body: 'This one uses a string slug!' }
};

// A dynamic route to get a single post by its ID (or "slug")
app.get('/posts/:postId', (req, res) => {
  // Get the dynamic ID from req.params
  const id = req.params.postId;
  
  // Find the post in our fake database
  const post = posts[id];
  
  if (post) {
    // If found, send it as JSON
    res.json(post);
  } else {
    // If not found, send a 404
    res.status(404).json({ error: 'Post not found' });
  }
});

app.listen(3000, () => console.log('Server running'));
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Terminal Commands</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-bash">
# Test post '1'
$ curl http://localhost:3000/posts/1
# {"title":"First Post","body":"This is post 1."}

# Test post 'my-third-post' (a "slug")
$ curl http://localhost:3000/posts/my-third-post
# {"title":"Third Post","body":"This one uses a string slug!"}

# Test a post that doesn't exist
$ curl http://localhost:3000/posts/999
# {"error":"Post not found"}
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>You cannot build a modern, data-driven application without dynamic routing. It's impossible to know every possible URL ahead of time (like every user profile, product page, or blog post). This technique allows you to create a single template (the route handler) that can serve an infinite number of pages.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>What is a "slug"? (A user-friendly string, like <code>"my-third-post"</code>, used in a URL instead of a number like <code>3</code>).</li>
            <li>How would you handle a route like <code>/users/:userId/books/:bookId</code>? (Both <code>userId</code> and <code>bookId</code> would be available in <code>req.params</code>).</li>
            <li>What if two routes conflict, like <code>/posts/new</code> and <code>/posts/:id</code>? (Order matters. Express tries to match routes in the order they are defined, so <code>/posts/new</code> must be defined *before* <code>/posts/:id</code>).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://expressjs.com/en/guide/routing.html#route-parameters" target="_blank" class="hover:underline">Express Docs: Route Parameters</a></li>
            <li><a href="https://masteringjs.io/tutorials/express/dynamic-routes" target="_blank" class="hover:underline">Mastering JS: Dynamic Routes in Express</a></li>
          </ul>
        </section>
      </div>
    `
  },
  
  {
    title: "What is Middleware?",
    difficulty: "Intermediate",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I understand middleware as a function that runs in the middle of the request-response cycle. It has access to the 'req' and 'res' objects and a 'next' function, which it must call to pass control to the next middleware or route handler in the stack."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>Middleware functions are the "plumbing" of an Express application. They are functions that execute <strong>between</strong> the server receiving a request and a route handler sending a response.</p>
          <p class="mt-2">Every middleware function has access to three arguments:</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong><code>req</code> (Request):</strong> The request object.</li>
            <li><strong><code>res</code> (Response):</strong> The response object.</li>
            <li><strong><code>next</code> (Next):</strong> A function that, when called, passes control to the next middleware function in the stack.</li>
          </ul>
          <p class="mt-2">A middleware function can:</p>
          <ul class="list-disc list-inside ml-4 mt-2">
            <li>Execute any code.</li>
            <li>Make changes to the <code>req</code> or <code>res</code> objects (e.g., <code>req.user = ...</code>).</li>
            <li>End the request-response cycle (e.g., <code>res.status(401).send('Unauthorized')</code>).</li>
            <li>Call <code>next()</code> to pass control to the next middleware.</li>
          </ul>
          <p class="mt-2"><strong>If you don't call <code>next()</code> or send a response, the request will hang forever!</strong></p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (A simple logger middleware)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
const express = require('express');
const app = express();

// 1. Define a custom middleware function
const loggerMiddleware = (req, res, next) => {
  console.log(\`[LOG] \${new Date().toISOString()}: \${req.method} \${req.url}\`);
  
  // 2. Add a custom property to 'req'
  req.requestTime = Date.now();
  
  // 3. Call next() to pass control to the next function
  next();
};

// 4. Use the middleware (more on this in the next topic)
app.use(loggerMiddleware);

app.get('/', (req, res) => {
  // We can access the property set by the middleware
  res.send(\`Hello! Your request time was \${req.requestTime}\`);
});

app.listen(3000, () => console.log('Server running...'));
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>Middleware is the most powerful concept in Express. It's how you handle almost every cross-cutting concern: parsing JSON bodies, checking for authentication tokens, logging requests, handling errors, serving static files, and more. Your application is essentially a stack of middleware functions.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>What happens if you don't call <code>next()</code>? (The request hangs, and the client eventually times out).</li>
            <li>What is an error-handling middleware? (A special middleware with 4 arguments: <code>(err, req, res, next)</code>).</li>
            <li>Can a middleware send a response? (Yes, it can end the cycle, e.g., an auth middleware sending a 401).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://expressjs.com/en/guide/writing-middleware.html" target="_blank" class="hover:underline">Express Docs: Writing middleware</a></li>
            <li><a href="https://expressjs.com/en/guide/using-middleware.html" target="_blank" class="hover:underline">Express Docs: Using middleware</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "Using Middleware: `app.use()`",
    difficulty: "Intermediate",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I use 'app.use()' to apply middleware. If I call it without a path, it runs on every request. If I provide a path, like 'app.use('/admin', ...)', it runs only on requests that start with that path. I know 'app.use()' is how I plug in features like 'express.json()' or authentication."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p><code>app.use()</code> is the primary method for "mounting" middleware functions onto your application. The order in which you <code>use</code> middleware is critical, as requests will flow through them in that order.</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong>Application-level middleware (no path):</strong>
              <ul>
                <li><code>app.use(myLogger);</code></li>
                <li>This middleware will run for <strong>every single request</strong> that comes into your server, regardless of the URL.</li>
              </ul>
            </li>
            <li><strong>Application-level middleware (with path):</strong>
              <ul>
                <li><code>app.use('/api', myApiAuth);</code></li>
                <li>This middleware will run for any request whose path <strong>starts with</strong> <code>/api</code> (e.g., <code>/api/users</code>, <code>/api/products</code>).</li>
              </ul>
            </li>
          </ul>
          <p class="mt-2">You can also apply middleware to a single route:</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong>Route-level middleware:</strong>
              <ul>
                <li><code>app.get('/secret-data', checkAdmin, (req, res) => { ... });</code></li>
                <li>Here, <code>checkAdmin</code> is a middleware that runs *only* for this specific <code>GET</code> route.</li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (Different app.use patterns)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
const express = require('express');
const app = express();

// 1. Application-level middleware (runs on EVERY request)
app.use((req, res, next) => {
  console.log('Time:', Date.now());
  next();
});

// 2. Path-specific middleware (runs on any request to /admin/...)
const adminAuth = (req, res, next) => {
  if (req.query.user === 'admin') {
    next();
  } else {
    res.status(403).send('Forbidden: Not an admin');
  }
};
app.use('/admin', adminAuth);

// 3. Route-level middleware (runs only for this route)
const checkId = (req, res, next) => {
  if (isNaN(parseInt(req.params.id))) {
    return res.status(400).send('Invalid ID format');
  }
  next();
};

// --- Routes ---

app.get('/', (req, res) => {
  res.send('Homepage (Time logged)');
});

app.get('/admin/dashboard', (req, res) => {
  res.send('Welcome, Admin! (Time logged, auth passed)');
});

// This route uses the 'checkId' middleware
app.get('/users/:id', checkId, (req, res) => {
  res.send(\`User details for ID \${req.params.id}\`);
});
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p><code>app.use()</code> is how you build your application's functionality. You "compose" your server by stacking middleware. Understanding how to apply middleware globally (for logging), to specific paths (for auth), or to individual routes (for validation) gives you complete control over the request lifecycle.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>What's the difference between <code>app.use('/foo', ...)</code> and <code>app.get('/foo', ...)</code>? (<code>app.use</code> matches any method and paths *starting with* <code>/foo</code>. <code>app.get</code> *only* matches <code>GET</code> requests for the *exact* path <code>/foo</code>).</li>
            <li>Does the order of <code>app.use()</code> calls matter? (Yes, absolutely. Requests pass through them in order).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://expressjs.com/en/4x/api.html#app.use" target="_blank" class="hover:underline">Express Docs: app.use()</a></li>
            <li><a href="https://expressjs.com/en/guide/using-middleware.html" target="_blank" class="hover:underline">Express Docs: Using middleware</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "Built-in Middleware",
    difficulty: "Beginner",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I'm familiar with Express's built-in middleware. I use 'express.json()' to parse incoming JSON payloads, 'express.urlencoded()' for form data, and 'express.static()' to serve files like HTML, CSS, and images directly from a folder."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>Express comes with a few extremely useful middleware functions that you'll use in almost every project.</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong><code>express.json()</code>:</strong>
              <ul>
                <li><strong>Purpose:</strong> Parses incoming requests with JSON payloads (<code>Content-Type: application/json</code>).</li>
                <li><strong>Effect:</strong> It takes the JSON string from the request body and puts the parsed JavaScript object onto <code>req.body</code>.</li>
              </ul>
            </li>
            <li><strong><code>express.urlencoded({ extended: true })</code>:</strong>
              <ul>
                <li><strong>Purpose:</strong> Parses incoming requests with URL-encoded payloads (<code>Content-Type: application/x-www-form-urlencoded</code>).</li>
                <li><strong>Effect:</strong> This is how HTML forms send data. It parses this data and puts it on <code>req.body</code>.</li>
              </ul>
            </li>
            <li><strong><code>express.static('public')</code>:</strong>
              <ul>
                <li><strong>Purpose:</strong> Serves static assets (HTML, CSS, JS, images).</li>
                <li><strong>Effect:</strong> It "exposes" a folder (e.g., <code>'public'</code>). If a request comes in for <code>/style.css</code>, Express will look for <code>public/style.css</code> and send it automatically.</li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (Using all three)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
const express = require('express');
const path = require('path');
const app = express();

// --- Setup ---
// 1. Serve static files from the 'public' directory
// e.g., http://localhost:3000/index.html
app.use(express.static(path.join(__dirname, 'public')));

// 2. Parse JSON bodies (for API requests)
app.use(express.json());

// 3. Parse URL-encoded bodies (for form submissions)
app.use(express.urlencoded({ extended: true }));

// --- Routes ---

// A POST route for a JSON API
app.post('/api/users', (req, res) => {
  // Thanks to express.json(), req.body has the data
  const newUser = req.body;
  console.log('JSON data:', newUser);
  res.json({ message: 'User created!', user: newUser });
});

// A POST route for an HTML form
app.post('/login', (req, res) => {
  // Thanks to express.urlencoded(), req.body has the data
  const { username, password } = req.body;
  console.log('Form data:', username);
  res.send(\`Welcome, \${username}\`);
});

app.listen(3000, () => console.log('Server running...'));
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>Without <code>express.json()</code> and <code>express.urlencoded()</code>, <code>req.body</code> would be <code>undefined</code>. You <strong>must</strong> use these to handle <code>POST</code> or <code>PUT</code> requests. <code>express.static()</code> is the standard way to serve a front-end (like a React or Vue app) from your Express server.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>What does <code>{ extended: true }</code> mean? (It allows for "rich" objects and arrays to be encoded, using the <code>qs</code> library. It's best practice to set it).</li>
            <li>Why do you need <code>path.join(__dirname, 'public')</code>? (To create an absolute path to the 'public' folder, which is safer than a relative path).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://expressjs.com/en/4x/api.html#express.json" target="_blank" class="hover:underline">Express Docs: express.json()</a></li>
            <li><a href="https://expressjs.com/en/4x/api.html#express.urlencoded" target="_blank" class="hover:underline">Express Docs: express.urlencoded()</a></li>
            <li><a href="https://expressjs.com/en/4x/api.html#express.static" target="_blank" class="hover:underline">Express Docs: express.static()</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "BodyParser (Legacy)",
    difficulty: "Beginner",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I know that 'bodyParser' was a separate npm package used to parse request bodies. However, I'm aware that its functionality is now built directly into Express (since v4.16), so I just use 'express.json()' and 'express.urlencoded()' instead."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>In older versions of Express (before 4.16.0), the <code>express.json()</code> and <code>express.urlencoded()</code> middleware did not exist. To parse request bodies, you had to install and use a separate package called <code>body-parser</code>.</p>
          <p class="mt-2">You will <strong>constantly</strong> see this in older tutorials, Stack Overflow answers, and existing projects. It's crucial to recognize this pattern and know that it is no longer necessary for modern projects.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (Legacy vs. Modern)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
// --- LEGACY WAY (Old tutorials, old projects) ---
// 1. npm install body-parser
const express = require('express');
const bodyParser = require('body-parser');
const app = express();

// 2. Use bodyParser middleware
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));

app.post('/submit', (req, res) => {
  // req.body is now available
});


// --- MODERN WAY (Express v4.16+) ---
const express = require('express');
const app = express();

// 1. No separate install needed
// 2. Use built-in middleware
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

app.post('/submit', (req, res) => {
  // req.body is now available
});
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>Knowing this saves you from confusion. If you see <code>require('body-parser')</code>, you should immediately think, "This is an older project, but I know what this code is doing." It also stops you from installing an unnecessary package in your new projects.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>If <code>express.json()</code> isn't working, what's the first thing you should check? (That <code>app.use(express.json())</code> is *before* your routes, and that the client is sending the <code>Content-Type: application/json</code> header).</li>
            <li>What if you need to parse a plain text body? (You can use <code>express.text()</code>).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://github.com/expressjs/body-parser" target="_blank" class="hover:underline">body-parser NPM Package</a></li>
            <li><a href="https://expressjs.com/en/4x/api.html#express.json" target="_blank" class="hover:underline">Express Docs: express.json() (see notes)</a></li>
          </ul>
        </section>
      </div>
    `
  },

  
  
  {
    title: "Express Router (`express.Router()`)",
    difficulty: "Intermediate",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I use 'express.Router()' to create modular, mountable route handlers. It lets me group all my '/users' routes in one file, for example, and then 'app.use('/users', usersRoutes)' in my main server file, which keeps my code clean and scalable."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>An <code>express.Router()</code> is like a "mini-app" or a "sub-app." It's an isolated instance of middleware and routes that can be mounted on a path in your main Express app.</p>
          <p class="mt-2">This is the primary way to organize your application. Instead of putting all 100 of your routes in <code>server.js</code>, you group them into logical files:</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><code>routes/users.js</code> (handles all <code>/users</code> routes)</li>
            <li><code>routes/products.js</code> (handles all <code>/products</code> routes)</li>
            <li><code>routes/admin.js</code> (handles all <code>/admin</code> routes)</li>
          </ul>
          <p class="mt-2">Inside these files, you define routes on the <strong>router</strong> instance (e.g., <code>router.get('/')</code>). In your main <code>server.js</code>, you just <code>require</code> and <code>app.use()</code> them.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (Modularizing routes)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
// --- File: routes/users.js ---
// This file defines all routes that start with /users

const express = require('express');
const router = express.Router(); // 1. Create a new router instance

// This is actually /users/
router.get('/', (req, res) => {
  res.send('Get all users');
});

// This is actually /users/:id
router.get('/:id', (req, res) => {
  res.send(\`Get user with ID \${req.params.id}\`);
});

module.exports = router; // 2. Export the router


// --- File: server.js (Main App) ---
const express = require('express');
const app = express();
const usersRoutes = require('./routes/users'); // 3. Import the router

// 4. Mount the router on the '/users' path
// Any request starting with /users will be handled by usersRoutes
app.use('/users', usersRoutes);

app.get('/', (req, res) => {
  res.send('Homepage');
});

app.listen(3000, () => console.log('Server running...'));
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>This is not optional; it's essential for scalability. A real-world application will have its routes split into many different files using <code>express.Router</code>. This keeps your main <code>server.js</code> file clean and organized, focusing only on high-level configuration and mounting routes.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>In the router file, why is <code>router.get('/')</code> not <code>router.get('/users')</code>? (Because the <code>/users</code> path is defined in <code>app.use()</code>. The router paths are *relative* to where they are mounted).</li>
            <li>Can a router have its own middleware? (Yes, you can use <code>router.use()</code> just like <code>app.use()</code>).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://expressjs.com/en/guide/routing.html#express-router" target="_blank" class="hover:underline">Express Docs: express.Router</a></li>
            <li><a href="https://www.digitalocean.com/community/tutorials/how-to-use-the-express-router" target="_blank" class="hover:underline">How To Use the Express Router (DigitalOcean)</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "Middleware Types: Application-level vs. Router-level",
    difficulty: "Intermediate",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I use application-level middleware with 'app.use()' for global tasks like logging, 'express.json()', or 'cors'. I use router-level middleware with 'router.use()' for tasks specific to a group of routes, like an 'isAdmin' check that only applies to my '/admin' router."
      </blockquote>

      <div class="space-y-6 text-gray-30AN_INJECT_1-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>Middleware can be applied at different "levels" in your application, giving you fine-grained control.</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong>Application-level Middleware:</strong>
              <ul>
                <li><strong>Bound to:</strong> The <code>app</code> instance (<code>app.use()</code>, <code>app.get()</code>).</li>
                <li><strong>Scope:</strong> Runs for all requests that match the path, or *all requests* if no path is given (e.g., <code>app.use(express.json())</code>).</li>
                <li><strong>Use Case:</strong> Global tasks: logging, body parsing, static files, global error handling.</li>
              </ul>
            </li>
            <li><strong>Router-level Middleware:</strong>
              <ul>
                <li><strong>Bound to:</strong> An <code>express.Router()</code> instance (<code>router.use()</code>, <code>router.get()</code>).</li>
                <li><strong>Scope:</strong> Runs *only* for requests that are handled by that specific router.</li>
                <li><strong>Use Case:</strong> Resource-specific tasks: authentication for all <code>/admin</code> routes, validation for all <code>/api</code> routes.</li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (Global logger vs. Specific auth)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
const express = require('express');
const app = express();

// --- 1. Application-level middleware (runs for ALL requests) ---
const globalLogger = (req, res, next) => {
  console.log(\`[GLOBAL] \${req.method} \${req.path}\`);
  next();
};
app.use(globalLogger);

// --- 2. Router-level middleware (runs only for this router) ---
const adminRouter = express.Router();

const checkAdminAuth = (req, res, next) => {
  if (req.query.token === 'admin123') {
    console.log('[ROUTER] Admin auth passed');
    next();
  } else {
    res.status(403).send('Forbidden: Admin access only');
  }
};

// Apply auth middleware to this *entire router*
adminRouter.use(checkAdminAuth);

adminRouter.get('/dashboard', (req, res) => {
  res.send('Admin Dashboard');
});

// --- Routes ---
app.get('/', (req, res) => {
  res.send('Public Homepage');
});

// Mount the admin router
app.use('/admin', adminRouter);

app.listen(3000, () => console.log('Server running...'));
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Terminal Commands</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-bash">
# 1. Accessing homepage (only global logger runs)
$ curl http://localhost:3000/
# [GLOBAL] GET /

# 2. Accessing admin route without auth (auth middleware blocks it)
$ curl http://localhost:3000/admin/dashboard
# [GLOBAL] GET /admin/dashboard
# Forbidden: Admin access only

# 3. Accessing admin route *with* auth (both middleware run)
$ curl "http://localhost:3000/admin/dashboard?token=admin123"
# [GLOBAL] GET /admin/dashboard
# [ROUTER] Admin auth passed
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>This separation of concerns is critical for security and organization. You don't want to run an expensive database check for user authentication on your public-facing <code>/</code> route. By applying auth at the router level (e.g., <code>app.use('/api', authRouter)</code>), you ensure that only the relevant requests are checked.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>What other types of middleware are there? (Error-handling, Built-in, Third-party).</li>
            <li>How would you apply middleware to just a single route? (<code>app.get('/path', myMiddleware, (req, res) => ...)</code>).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://expressjs.com/en/guide/using-middleware.html#middleware.router" target="_blank" class="hover:underline">Express Docs: Router-level middleware</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "Advanced Routing: `.route()` and `.all()`",
    difficulty: "Intermediate",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "For a single URL that needs different handlers for different verbs, I use '.route(\`/path\`)' to chain them, like '.get()', '.post()', and '.put()'. This avoids duplicating the route path and keeps my code DRY. I use 'app.all()' to run a handler for *all* HTTP methods on a path, often for validation."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>These are two special routing methods that give you more control.</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong><code>.route(path)</code>:</strong>
              <ul>
                <li><strong>Purpose:</strong> Creates a chainable route handler for a single path. This is a great way to group all logic for a single resource.</li>
                <li><strong>Benefit:</strong> It's cleaner and more readable (D.R.Y. - Don't Repeat Yourself) than writing <code>app.get(path)</code>, <code>app.post(path)</code>, etc.</li>
              </ul>
            </li>
            <li><strong><code>app.all(path, handler)</code>:</strong>
              <ul>
                <li><strong>Purpose:</strong> Matches *all* HTTP verbs (GET, POST, PUT, DELETE, etc.) for a specific path.</li>
                <li><strong>Benefit:</strong> Useful for applying a middleware to a specific route (e.g., auth, validation) or for a "catch-all" handler.</li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (Using .route() and .all())</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
const express = require('express');
const app = express();

// --- 1. Using .route() for a clean REST API ---

app.route('/api/items/:id')
  .get((req, res) => {
    res.send(\`Get item \${req.params.id}\`);
  })
  .put((req, res) => {
    res.send(\`Update item \${req.params.id}\`);
  })
  .delete((req, res) => {
    res.send(\`Delete item \${req.params.id}\`);
  });

// This is cleaner than:
// app.get('/api/items/:id', ...);
// app.put('/api/items/:id', ...);
// app.delete('/api/items/:id', ...);


// --- 2. Using app.all() to protect a specific route ---

const checkAuth = (req, res, next) => {
  console.log('Checking auth for secret path...');
  next();
};

app.all('/secret-document', checkAuth, (req, res) => {
  // This handler will run after checkAuth, for ANY method
  res.send(\`Secret document accessed via \${req.method}\`);
});

app.listen(3000, () => console.log('Server running...'));
            </code></pre>
          </div>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Terminal Commands</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-bash">
# Test the .route() chain
$ curl http://localhost:3000/api/items/123
# Get item 123
$ curl -X PUT http://localhost:3000/api/items/123
# Update item 123

# Test the .all() route
$ curl http://localhost:3000/secret-document
# Secret document accessed via GET
$ curl -X POST http://localhost:3000/secret-document
# Secret document accessed via POST
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p><code>.route()</code> is the standard for building clean, resource-oriented REST APIs. It groups all logic for one resource in one place. <code>app.all()</code> is a powerful, specific tool for middleware-like tasks that need to apply to all HTTP methods for a single route, but not its children.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>What's the difference between <code>app.all('/foo', ...)</code> and <code>app.use('/foo', ...)</code>? (<code>app.use</code> matches <code>/foo</code> and any path *starting with* it, like <code>/foo/bar</code>. <code>app.all</code> only matches the *exact* path <code>/foo</code>).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://expressjs.com/en/4x/api.html#app.route" target="_blank" class="hover:underline">Express Docs: app.route()</a></li>
            <li><a href="https://expressjs.com/en/4x/api.html#app.all" target="_blank" class="hover:underline">Express Docs: app.all()</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "App Settings: `app.set()`, `app.locals`, `res.locals`",
    difficulty: "Advanced",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I use 'app.set()' to store app-wide config, like a view engine or a secret key. I use 'app.locals' to set global variables for all templates, and 'res.locals' inside middleware to pass request-specific data, like the current user, to my route handler or template."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>These are different ways to store and access settings and variables in your app.</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong><code>app.set(key, value)</code>:</strong>
              <ul>
                <li><strong>Purpose:</strong> Sets application settings. Used for both Express's internal settings (e.g., <code>'view engine'</code>, <code>'views'</code>) and your own custom settings (e.g., <code>'jwtSecret'</code>).</li>
                <li><strong>Access:</strong> Retrieve with <code>app.get(key)</code>.</li>
              </ul>
            </li>
            <li><strong><code>app.locals</code>:</strong>
              <ul>
                <li><strong>Purpose:</strong> An object. Properties added here are available as variables in *all* templates rendered by the app, for its entire lifetime.</li>
                <li><strong>Use Case:</strong> Setting global variables like <code>app.locals.appName = 'My Site'</code>.</li>
              </ul>
            </li>
            <li><strong><code>res.locals</code>:</strong>
              <ul>
                <li><strong>Purpose:</strong> An object. Properties added here are available as variables in templates, but *only for the current request*.</li>
                <li><strong>Use Case:</strong> This is the standard way to pass data from middleware to your route handler/template (e.g., an auth middleware adds <code>res.locals.user = ...</code>).</li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (Passing data to templates)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
const express = require('express');
const app = express();

// 1. Set an Express-native setting
app.set('view engine', 'pug'); // Assuming 'pug' is installed
app.set('views', './my-templates');

// 2. Set a custom app-level variable (global for all templates)
app.locals.siteName = 'My Awesome App';

// 3. Use middleware to set a request-level variable
app.use((req, res, next) => {
  // This is specific to THIS request
  res.locals.requestTime = new Date().toLocaleTimeString();
  
  // Example: pass user info from auth (if it existed)
  res.locals.user = req.query.user || 'Guest';
  next();
});

app.get('/', (req, res) => {
  // res.locals.user is "Guest" or from query
  // app.locals.siteName is "My Awesome App"
  // This template can access 'siteName', 'requestTime', and 'user'
  res.render('index', { pageTitle: 'Homepage' });
});

// --- In your 'my-templates/index.pug' file ---
// html
//   head
//     title= pageTitle + ' | ' + siteName
//   body
//     h1 Welcome to \${siteName}, \${user}!
//     p Page loaded at: \${requestTime}
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>This is the correct way to manage global settings and pass data through the request lifecycle. <code>res.locals</code> is especially crucial for decoupling auth/validation middleware from route handlers. Your auth middleware finds the user, adds it to <code>res.locals</code>, and your route handler can then use it without re-fetching it.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>What's the difference between <code>app.set('foo', 'bar')</code> and <code>app.locals.foo = 'bar'</code>? (<code>app.set</code> is for config, <code>app.locals</code> is for template variables. Though <code>app.set</code> can also set template variables, it's clearer to use <code>app.locals</code>).</li>
            <li>Is <code>res.locals</code> secure? (It only exists on the server, for that one request. It is never sent to the client, unless you explicitly render it in a template).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://expressjs.com/en/4x/api.html#app.set" target="_blank" class="hover:underline">Express Docs: app.set()</a></li>
            <li><a href="https://expressjs.com/en/4x/api.html#app.locals" target="_blank" class="hover:underline">Express Docs: app.locals</a></li>
            <li><a href="https://expressjs.com/en/4x/api.html#res.locals" target="_blank" class="hover:underline">Express Docs: res.locals</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "Response Methods: `send()` vs. `json()` vs. `end()`",
    difficulty: "Intermediate",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I know the common 'res' methods. I almost always use 'res.json()' for APIs as it sets the 'Content-Type' header correctly. I use 'res.send()' for simple text or HTML. I only use 'res.end()' if I need to end the request with no body, like for a '204 No Content' response."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>These methods all end the request-response cycle, but they have key differences.</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong><code>res.json([body])</code>:</strong>
              <ul>
                <li><strong>Purpose:</strong> Sends a JSON response.</li>
                <li><strong>Headers:</strong> Automatically sets <code>Content-Type: application/json</code>.</li>
                <li><strong>Use Case:</strong> The standard for 99% of REST API responses.</li>
              </ul>
            </li>
            <li><strong><code>res.send([body])</code>:</strong>
              <ul>
                <li><strong>Purpose:</strong> A flexible method that sends a response with a body.</li>
                <li><strong>Headers:</strong> Tries to guess the <code>Content-Type</code>. (e.g., <code>text/html</code> for <code>'&lt;h1&gt;'</code>, <code>application/json</code> for <code>{a:1}</code>).</li>
                <li><strong>Use Case:</strong> Good for simple text, HTML, or quick tests.</li>
              </ul>
            </li>
            <li><strong><code>res.end([data])</code>:</strong>
              <ul>
                <li><strong>Purpose:</strong> A low-level Node.js method. Ends the response.</li>
                <li><strong>Headers:</strong> Does NOT set <code>Content-Type</code> or other headers automatically.</li>
                <li><strong>Use Case:</strong> Rarely used directly. Best for "No Content" responses: <code>res.status(204).end()</code>.</li>
              </ul>
            </li>
            <li><strong><code>res.write(chunk)</code>:</strong> (Related)
              <ul>
                <li><strong>Purpose:</strong> A low-level stream method. Writes a chunk of data.</li>
                <li><strong>This does NOT end the response.</strong> You must call <code>res.end()</code> manually. You should almost never use this; use <code>.pipe()</code> instead.</li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (Comparing methods)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
const express = require('express');
const app = express();

// 1. Preferred for APIs
app.get('/api', (req, res) => {
  // Sets Content-Type: application/json
  res.json({ success: true, data: [1, 2, 3] });
});

// 2. Good for simple HTML/text
app.get('/hello', (req, res) => {
  // Sets Content-Type: text/html
  res.send('<h1>Hello World</h1>');
});

// 3. Good for "No Content" responses
app.delete('/api/items/1', (req, res) => {
  // Does not send a body
  res.status(204).end();
});

// 4. res.send is smart, but res.json is clearer
app.get('/api-send', (req, res) => {
  // This *works* (sets Content-Type: application/json)
  // But res.json() is more explicit and preferred.
  res.send({ success: true, data: [1, 2, 3] });
});
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>Using the right method is professional and prevents bugs. Using <code>res.json()</code> for APIs is standard practice. Using <code>res.end()</code> by mistake can lead to responses with no <code>Content-Type</code>, which will break your front-end. Understanding that <code>res</code> is a stream (which is why <code>.write</code> and <code>.end</code> exist) is a key Node.js concept.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>What's the difference between <code>res.send({a:1})</code> and <code>res.json({a:1})</code>? (In modern Express, almost nothing. <code>res.json()</code> is just more explicit and guarantees JSON-specific formatting settings).</li>
            <li>What is <code>res.sendStatus(404)</code>? (It's a shortcut. It's the same as <code>res.status(404).send('Not Found')</code>).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://expressjs.com/en/4x/api.html#res.json" target="_blank" class="hover:underline">Express Docs: res.json()</a></li>
            <li><a href="https://expressjs.com/en/4x/api.html#res.send" target="_blank" class="hover:underline">Express Docs: res.send()</a></li>
            <li><a href="https://expressjs.com/en/4x/api.html#res.end" target="_blank" class="hover:underline">Express Docs: res.end()</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "Serving Static Files",
    difficulty: "Beginner",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I serve static files like CSS, images, and client-side JavaScript using the 'express.static()' built-in middleware. I know to create a 'public' directory, point the middleware to it, and then I can access those files from the root URL of my site."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>Static files are any files that your server sends to the client *as-is*, without any processing. This includes <code>.css</code> files, <code>.js</code> files (for the browser), images (<code>.png</code>, <code>.jpg</code>), fonts, and even static <code>.html</code> files.</p>
          <p class="mt-2">The <code>express.static()</code> middleware "unlocks" a folder and makes its contents accessible via HTTP. The standard convention is to create a folder named <code>public</code> for all your static assets.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (Setting up a 'public' folder)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
const express = require('express');
const path = require('path');
const app = express();

// --- Folder Structure ---
// my-project/
//  |- server.js
//  |- public/
//  |  |- css/
//  |  |  |- style.css
//  |  |- js/
//  |  |  |- app.js
//  |  |- images/
//  |  |  |- logo.png
//  |  |- index.html

// 1. Point express.static to the 'public' folder
// We use path.join(__dirname, 'public') for a reliable absolute path
const publicPath = path.join(__dirname, 'public');
app.use(express.static(publicPath));

// 2. How it works:
// - A request for http://localhost:3000/css/style.css
//   ...will be served 'public/css/style.css'
// - A request for http://localhost:3000/images/logo.png
//   ...will be served 'public/images/logo.png'
// - A request for http://localhost:3000/
//   ...will be served 'public/index.html' (special case)

app.get('/about', (req, res) => {
  res.send('This is a dynamic route, not a static file.');
});

app.listen(3000, () => console.log('Server running...'));
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>This is a fundamental requirement for any web application. Your server-rendered HTML is useless without CSS to style it and client-side JavaScript to make it interactive. <code>express.static()</code> is the standard, built-in way to do this.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>What happens if you request <code>/</code> and there's an <code>index.html</code> in your static folder? (<code>express.static</code> will serve it by default).</li>
            <li>What if you want your static files to be prefixed, like <code>/static/css/style.css</code>? (You mount it: <code>app.use('/static', express.static('public'))</code>).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://expressjs.com/en/starter/static-files.html" target="_blank" class="hover:underline">Express Docs: Serving static files</a></li>
            <li><a href="https://expressjs.com/en/4x/api.html#express.static" target="_blank" class="hover:underline">Express Docs: express.static()</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "Partials (reusable template components)",
    difficulty: "Intermediate",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I use partials to keep my templates DRY. I create reusable template files for common components like a header, footer, or navbar, and then I use my view engine's 'include' syntax, like '&lt;%- include('partials/header') %&gt;' in EJS, to pull them into my main templates."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p><strong>Partials</strong> are small, reusable template files. You don't want to copy and paste your navigation bar or your <code>&lt;head&gt;</code> tag into every single <code>.ejs</code> file. Instead, you create one partial for it (e.g., <code>header.ejs</code>) and then "include" it in all your other templates.</p>
          <p class="mt-2">This follows the <strong>DRY (Don't Repeat Yourself)</strong> principle. If you need to add a new nav link, you only have to edit <code>header.ejs</code> once.</p>
          <p class="mt-2">In EJS, the syntax is: <code>&lt;%- include('path/to/partial') %&gt;</code>. (You often use <code>&lt;%-</code> to allow partials to render HTML).</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (Using EJS Partials)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
// --- Folder Structure ---
// views/
//  |- pages/
//  |  |- index.ejs
//  |  |- about.ejs
//  |- partials/
//  |  |- header.ejs
//  |  |- footer.ejs
// server.js

// --- File: views/partials/header.ejs ---
// &lt;!DOCTYPE html&gt;
// &lt;html lang="en"&gt;
// &lt;head&gt;
//   &lt;title&gt;&lt;%= title %&gt; | MySite&lt;/title&gt; &lt;!-- 'title' is passed from res.render --&gt;
//   &lt;link rel="stylesheet" href="/css/style.css"&gt;
// &lt;/head&gt;
// &lt;body&gt;
//   &lt;nav&gt;
//     &lt;a href="/"&gt;Home&lt;/a&gt; | &lt;a href="/about"&gt;About&lt;/a&gt;
//   &lt;/nav&gt;

// --- File: views/partials/footer.ejs ---
//   &lt;footer&gt;
//     &lt;p&gt;&copy; 2025 MySite&lt;/p&gt;
//   &lt;/footer&gt;
// &lt;/body&gt;
// &lt;/html&gt;

// --- File: views/pages/index.ejs ---
// &lt;%- include('../partials/header', { title: 'Homepage' }) %&gt;
//
// &lt;h1&gt;Welcome to the Homepage&lt;/h1&gt;
// &lt;p&gt;This is the main content.&lt;/p&gt;
//
// &lt;%- include('../partials/footer') %&gt;

// --- File: server.js ---
app.set('view engine', 'ejs');
app.get('/', (req, res) => {
  // EJS knows to look for 'views/pages/index.ejs'
  // We pass 'title' so the header partial can use it
  res.render('pages/index', { title: 'Home' });
});
app.get('/about', (req, res) => {
  res.render('pages/about', { title: 'About Us' });
});
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>Partials are fundamental to template maintainability. Without them, a simple change to your website's footer would require you to edit every single page. Partials are the view-layer equivalent of writing a reusable function instead of copy-pasting code.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>How do you pass data to a partial? (In EJS, you can pass a data object as the second argument to <code>include</code>, as shown with <code>{ title: 'Homepage' }</code>. If you don't, the partial inherits the data from <code>res.render</code>).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://ejs.co/#includes" target="_blank" class="hover:underline">EJS Docs: Includes</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "`res.render()` vs. `res.redirect()`",
    difficulty: "Intermediate",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I know the difference: 'res.render()' sends back HTML from a template, while 'res.redirect()' sends a 302 status and a 'Location' header to tell the browser to make a *new* request to a different URL. I use 'render' to show a page, and 'redirect' to move the user, like after a form submission."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>These two methods are often confused, but they are completely different.</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong><code>res.render('template', {data})</code>:</strong>
              <ul>
                <li><strong>What it does:</strong> Server-side action. Finds your template, combines it with data, and sends the resulting <strong>HTML</strong> to the browser.</li>
                <li><strong>Browser URL:</strong> The URL in the browser bar <strong>does not change</strong>. If they visited <code>/profile</code>, the URL stays <code>/profile</code>.</li>
                <li><strong>Use Case:</strong> Showing a page to the user.</li>
              </ul>
            </li>
            <li><strong><code>res.redirect('/new-url')</code>:</strong>
              <ul>
                <li><strong>What it does:</strong> Client-side action. Sends a special response (<code>302 Found</code> status) with a <code>Location: /new-url</code> header.</li>
                <li><strong>Browser URL:</strong> The browser sees this, says "OK, I need to go elsewhere," and makes a <strong>brand new GET request</strong> to <code>/new-url</code>. The URL in the bar <strong>changes</strong>.</li>
                <li><strong>Use Case:</strong> Moving the user after an action (like a <code>POST</code> request), or for protected routes.</li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (Login Form)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
const express = require('express');
app.use(express.urlencoded({ extended: true }));

// 1. RENDER: Show the login page
app.get('/login', (req, res) => {
  // 'error' might come from a failed query param
  res.render('login-form', { error: req.query.error });
});

// 2. REDIRECT: Handle the form submission
app.post('/login', (req, res) => {
  const { username, password } = req.body;

  if (username === 'admin' && password === 'pass') {
    // SUCCESS: User's action (POST) is done.
    // Tell their browser to go to a new page (GET /dashboard)
    res.redirect('/dashboard');
  } else {
    // FAILURE: User's action (POST) failed.
    // Tell their browser to go back to the login page (GET /login)
    // We add a query param to show an error
    res.redirect('/login?error=Invalid+credentials');
  }
});

app.get('/dashboard', (req, res) => {
  // 3. RENDER: Show the dashboard page
  res.render('dashboard', { user: 'admin' });
});
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>This is critical for web flow. You should *never* <code>render</code> a page on a <code>POST</code> request. This breaks the browser's "back" button and can cause forms to be re-submitted. The correct pattern is <strong>Post-Redirect-Get (PRG)</strong>: handle the <code>POST</code>, then <code>redirect</code> to a <code>GET</code> route, which then <code>renders</code> the page.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>What happens if you try to <code>res.render()</code> *after* <code>res.redirect()</code>? (You get an error: "Cannot set headers after they are sent." The redirect already sent the response).</li>
            <li>What status code does <code>res.redirect()</code> use? (302 Found by default. You can change it: <code>res.redirect(301, '/new-url')</code> for a permanent move).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://expressjs.com/en/4x/api.html#res.render" target="_blank" class="hover:underline">Express Docs: res.render()</a></li>
            <li><a href="https://expressjs.com/en/4x/api.html#res.redirect" target="_blank" class="hover:underline">Express Docs: res.redirect()</a></li>
            <li><a href="https://en.wikipedia.org/wiki/Post/Redirect/Get" target="_blank" class="hover:underline">Post/Redirect/Get (PRG) Pattern</a></li>
          </ul>
        </section>
      </div>
    `
  },

  {
    type: "heading",
    title: "Node Advanced"
  },
  {
    title: "Event Loop Phases",
    difficulty: "Advanced",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I know the event loop isn't just one queue. It's a series of phases that run in a specific order, like 'timers' for 'setTimeout', 'poll' for I/O, and 'check' for 'setImmediate'. Crucially, the microtask queue drains *after each* phase."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>The Node.js event loop is a "loop" that runs as long as your application has work to do. Think of it as a manager with a specific checklist they go through in a circle. The main phases are:</p>
          <ol class="list-decimal list-inside ml-4 mt-2 space-y-1">
            <li><strong>Timers:</strong> Runs callbacks for <code>setTimeout()</code> and <code>setInterval()</code> that are due.</li>
            <li><strong>Pending Callbacks:</strong> (Internal use) Executes I/O callbacks that were deferred to the next loop.</li>
            <li><strong>Poll:</strong> The main phase. It retrieves new I/O events (like a file read finishing) and runs their callbacks. If there's nothing, it will "poll" (wait) for new events.</li>
            <li><strong>Check:</strong> Runs callbacks scheduled with <code>setImmediate()</code>. This phase runs right after the Poll phase.</li>
            <li><strong>Close Callbacks:</strong> Runs cleanup code, like <code>socket.on('close', ...)</code>.</li>
          </ol>
          <p class="mt-2"><strong>The most important rule:</strong> After your synchronous code finishes, and *after each phase* of the event loop, Node.js <strong>immediately</strong> runs all tasks in the <strong>Microtask Queue</strong> (<code>Promise.then</code>, <code>process.nextTick</code>) until it's empty.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (Timers vs. Check vs. Microtask)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
const fs = require('fs');

console.log('1. Start');

// Timer (Macrotask - Timers Phase)
setTimeout(() => {
  console.log('5. Timer (setTimeout)');
}, 0);

// Check (Macrotask - Check Phase)
setImmediate(() => {
  console.log('6. Check (setImmediate)');
});

// Microtask
Promise.resolve().then(() => {
  console.log('3. Microtask (Promise)');
});

// I/O (Macrotask - Poll Phase)
fs.readFile(__filename, () => {
  console.log('4. Poll (I/O complete)');
});

console.log('2. End');

// --- Expected Order: ---
// 1. Start
// 2. End
// 3. Microtask (Promise) - (Runs right after sync code)
// 4. Poll (I/O complete) - (Runs when I/O is done)
// 5. Timer (setTimeout)  - (Runs in Timers phase)
// 6. Check (setImmediate) - (Runs in Check phase, after Poll)

// Note: The order of 4, 5, and 6 can vary based on
// how long the I/O (4) takes. But 3 *always* runs before them.
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>This explains *why* Node.js is asynchronous and how it works. Understanding this order allows you to predict your code's execution flow and debug tricky, non-deterministic bugs (like when a <code>setTimeout(0)</code> runs before or after a <code>setImmediate</code>).</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>What happens if you have a <code>while(true)</code> loop? (It blocks the main thread, and the event loop *never* gets to run. The server freezes).</li>
            <li>Inside an I/O callback, what runs first: <code>setTimeout(0)</code> or <code>setImmediate()</code>? (<code>setImmediate</code>, because the Poll phase moves to the Check phase before looping back to Timers).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick" target="_blank" class="hover:underline">Node.js Docs: The Event Loop, Timers, and nextTick()</a></li>
            <li><a href="https://www.youtube.com/watch?v=PNa9OMajw9w" target="_blank" class="hover:underline">What the heck is the event loop anyway? (Video)</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "Microtask vs. Macrotask Queue",
    difficulty: "Advanced",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I know the two main task queues. Macrotasks (like 'setTimeout', I/O) are handled one at a time by the event loop's phases. Microtasks (like 'Promise.then', 'process.nextTick') are a *higher priority* queue that drains *immediately* after the current synchronous code and *after each* macrotask."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>Think of it like a to-do list at a hospital.</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong>Macrotask Queue (or "Task Queue"):</strong>
              <ul>
                <li><strong>What:</strong> The "regular patients" waiting.</li>
                <li><strong>Examples:</strong> <code>setTimeout</code>, <code>setImmediate</code>, <code>setInterval</code>, I/O (file reads, network).</li>
                <li><strong>How:</strong> The event loop takes *one* task from this queue, runs it, and then moves on.</li>
              </ul>
            </li>
            <li><strong>Microtask Queue:</strong>
              <ul>
                <li><strong>What:</strong> The "emergency room" (ER). These are high-priority.</li>
                <li><strong>Examples:</strong> <code>Promise.then()</code>, <code>.catch()</code>, <code>.finally()</code>, <code>process.nextTick()</code>.</li>
                <li><strong>How:</strong> After your main script finishes, AND after *every single macrotask* finishes, the event loop *must* check the ER. It will run *all* tasks in the microtask queue until it's empty before it's allowed to take the *next* macrotask.</li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (The Classic Log Order)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
console.log('1. Sync Start');

// Macrotask
setTimeout(() => {
  console.log('5. Macrotask (setTimeout)');
}, 0);

// Microtask
Promise.resolve().then(() => {
  console.log('3. Microtask (Promise.then)');
});

// Special Microtask (highest priority)
process.nextTick(() => {
  console.log('2. Microtask (process.nextTick)');
});

console.log('4. Sync End');

// --- Expected Order: ---
// 1. Sync Start
// 4. Sync End
// (Sync code finishes. Now, drain microtasks.)
// 2. Microtask (process.nextTick) - (Higher priority microtask)
// 3. Microtask (Promise.then)
// (Microtasks empty. Now, start event loop for macrotasks.)
// 5. Macrotask (setTimeout) - (From Timers phase)
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>This explains *why* <code>async/await</code> and Promises feel so "immediate." A <code>Promise.then()</code> will *always* run before a <code>setTimeout(0)</code>, because microtasks are a higher priority and run before the event loop's timer phase even begins.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>What's the difference between <code>process.nextTick</code> and <code>Promise.then</code>? (Both are microtasks, but <code>nextTick</code> has a higher priority and will run before other microtasks).</li>
            <li>What happens if a microtask queues another microtask? (It gets added to the *same* microtask queue and will also run before the next macrotask. This can "starve" the event loop).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide" target="_blank" class="hover:underline">MDN: Microtask Guide</a></li>
            <li><a href="https.blog.risingstack.com/node-js-at-scale-understanding-the-event-loop/" target="_blank" class="hover:underline">Understanding the Event Loop (RisingStack)</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "`process.nextTick()` vs. `setImmediate()`",
    difficulty: "Advanced",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "This is a classic question. 'process.nextTick' is a high-priority *microtask* that runs immediately after the current operation, before the event loop continues. 'setImmediate' is a *macrotask* that runs in the 'check' phase of the event loop, after the 'poll' (I/O) phase."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>This is the clearest way to see the difference between the microtask and macrotask queues.</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong><code>process.nextTick(callback)</code>:</strong>
              <ul>
                <li><strong>Queue:</strong> Microtask (high priority).</li>
                <li><strong>When it runs:</strong> "Next tick" is a bad name. It should be "right now, after this." It runs *immediately* after the current synchronous code, before the event loop is allowed to proceed to its next phase (like Timers or Poll).</li>
              </ul>
            </li>
            <li><strong><code>setImmediate(callback)</code>:</strong>
              <ul>
                <li><strong>Queue:</strong> Macrotask (Check phase).</li>
                <li><strong>When it runs:</strong> "Immediately" is also a bad name. It means "run on the next cycle of the event loop, specifically in the Check phase." This runs *after* the Poll (I/O) phase.</li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (Clear Order)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
console.log('1. Start');

// Macrotask
setImmediate(() => {
  console.log('4. setImmediate (Macrotask - Check Phase)');
});

// Microtask
process.nextTick(() => {
  console.log('3. process.nextTick (Microtask)');
});

console.log('2. End');

// --- Expected Order: ---
// 1. Start
// 2. End
// (Sync code finishes. Now, drain microtasks.)
// 3. process.nextTick (Microtask)
// (Microtasks empty. Now, start event loop.)
// (Timers phase is empty)
// (Poll phase is empty)
// 4. setImmediate (Check Phase)
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p><code>process.nextTick</code> allows you to "cut in line" with the highest possible priority, which can be useful but also dangerous (you can starve the event loop). <code>setImmediate</code> is a "safer" way to yield to the event loop and let any I/O finish before your code runs.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>Which has higher priority: <code>process.nextTick</code> or <code>Promise.then</code>? (<code>process.nextTick</code>).</li>
            <li>What runs first: <code>setTimeout(0)</code> or <code>setImmediate()</code>? (It's non-deterministic *unless* you are inside an I/O callback, in which case <code>setImmediate</code> *always* runs first).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://nodejs.org/api/timers.html#setimmediatecallback-args" target="_blank" class="hover:underline">Node.js Docs: setImmediate()</a></li>
            <li><a href="https://nodejs.org/api/process.html#processnexttickcallback-args" target="_blank" class="hover:underline">Node.js Docs: process.nextTick()</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "The Thread Pool (libuv)",
    difficulty: "Advanced",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I know Node's event loop is single-threaded, but libuv uses a thread pool (default size 4) to handle *blocking* operations asynchronously. Heavy tasks like 'fs.readFile' or 'crypto.pbkdf2' are passed to this pool, so the main event loop isn't blocked. When the thread finishes, it queues a callback to run in the 'poll' phase."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>The "Node.js is single-threaded" idea is only half-true. Your JavaScript code runs on one main thread (the event loop). But Node.js (via the C++ library <strong>libuv</strong>) has a <strong>Thread Pool</strong>, which is a small group of (by default, 4) other threads.</p>
          <p class="mt-2">Analogy: The Event Loop is a manager. The Thread Pool is a team of 4 workers.</p>
          <ol class="list-decimal list-inside ml-4 mt-2 space-y-1">
            <li>A request comes in for a *heavy, blocking task* (like reading a file or a hard crypto calculation).</li>
            <li>The manager (Event Loop) <strong>does not</strong> do this work. It would block the phone line.</li>
            <li>The manager gives the task to one of the 4 workers (Thread Pool) and immediately goes back to answering the phone (handling other requests).</li>
            <li>When the worker finishes, they put the result on the manager's desk.</li>
            <li>The manager (in the Poll phase) sees the finished work, and runs the callback.</li>
          </ol>
          <p class="mt-2">This is how Node.js achieves asynchronicity for tasks that are inherently blocking at the OS level (like most <code>fs</code> and <code>crypto</code> operations).</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (Blocking the Thread Pool)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
const crypto = require('crypto');
const fs = require('fs');

const start = Date.now();

// This function is heavy and uses the thread pool
const runHash = (id) => {
  crypto.pbkdf2('password', 'salt', 100000, 512, 'sha512', () => {
    console.log(\`Hash \${id} complete: \${Date.now() - start}ms\`);
  });
};

// --- Main Thread ---
console.log('Main thread: Running 5 hashes...');

// These 4 will run in *parallel* on the 4 threads in the pool
runHash(1);
runHash(2);
runHash(3);
runHash(4);

// This 5th hash must *wait* for one of the first 4 to finish
runHash(5);

// This is NOT blocked by the hashes, it runs right away
console.log('Main thread: Hashes started, moving on...');

// This I/O task ALSO uses the thread pool,
// so it has to wait for a free thread.
fs.readFile(__filename, () => {
  console.log(\`FS Read complete: \${Date.now() - start}ms\`);
});
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>This demystifies Node.js. It's not "magic." It's a single-threaded event loop *plus* a multi-threaded pool for heavy lifting. It also shows a performance bottleneck: if you have 5 heavy crypto tasks, the 5th one (and any file I/O) has to wait for the default 4 threads to finish.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>How can you change the thread pool size? (Set the <code>UV_THREADPOOL_SIZE</code> environment variable).</li>
            <li>What *doesn't* use the thread pool? (Network I/O, like <code>http.get</code>. Modern OSes handle this without blocking, so libuv uses that instead. It's much faster).</li>
            <li>What are <code>worker_threads</code>? (A *new* way to create *more* threads for your own CPU-heavy JavaScript code).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://nodejs.org/api/libuv.html#thread-pool" target="_blank" class="hover:underline">Node.js Docs: The libuv Thread Pool</a></li>
            <li><a href="https://docs.libuv.org/en/v1.x/threadpool.html" target="_blank" class="hover:underline">libuv Docs: Thread pool</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "How Node.js Handles Concurrency",
    difficulty: "Advanced",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "Node.js achieves high concurrency on a single thread by using an event-driven, non-blocking I/O model. It can handle thousands of connections at once because the main thread *never waits*. It just starts an I/O operation (like a database query) and registers a callback, then immediately moves on to the next request."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>This is the "big idea" that combines all the previous topics.</p>
          <p class="mt-2"><strong>Concurrency vs. Parallelism:</strong></p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong>Parallelism:</strong> Doing multiple things at the *exact same time* (e.g., 4 CPU cores running 4 tasks).</li>
            <li><strong>Concurrency:</strong> *Managing* multiple tasks at the same time (e.g., a chef has 10 pans on the stove, but only one set of hands. They give attention to each pan *as needed*).</li>
          </ul>
          <p class="mt-2">Node.js is <strong>concurrent</strong>. The Event Loop is the "chef." It handles thousands of "pans" (requests) at once.</p>
          <p class="mt-2"><strong>How it works (The "Receptionist" Analogy):</strong></p>
          <ol class="list-decimal list-inside ml-4 mt-1">
            <li>The Event Loop is a receptionist at a busy office, with a single phone line.</li>
            <li><strong>User 1 calls:</strong> "Hi, I need you to find a large file for me."</li>
            <li><strong>Receptionist (Event Loop):</strong> "Sure!" The receptionist *doesn't* go look for the file. They send a "worker" (from the Thread Pool) to get it. "I'll call you back when it's ready." They hang up, freeing the line.</li>
            <li><strong>User 2 calls:</strong> "Hi, I need to look up a simple database value."</li>
            <li><strong>Receptionist:</strong> "Sure!" They send a (fast, non-blocking) request to the database. "I'll call you back." They hang up.</li>
            <li>...This repeats for 10,000 users. The receptionist's line is always free.</li>
            <li>The database (fast) calls back first. The receptionist (Event Loop) picks up, gets the data, and sends it to User 2.</li>
            <li>The worker (slow) comes back with the file. The receptionist gets the file and sends it to User 1.</li>
          </ol>
          <p class="mt-2">The "receptionist" (main thread) is never blocked. It just takes requests and handles callbacks as they become ready.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>This is the *entire* reason Node.js is so popular. It's incredibly efficient for I/O-bound applications (like APIs, web servers, chat apps) because it uses very little memory per connection, unlike older models (like Apache) that would create a new thread (which is very "expensive") for every single user.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>What is an "I/O-bound" application? (An app where the bottleneck is "waiting" for things, like a database or a file, not "thinking" (CPU)).</li>
            <li>When would Node.js be a *bad* choice? (For heavy, CPU-bound tasks, like video encoding, where one long calculation would block the event loop for everyone).</li>
            <li>How can you do true *parallelism* in Node.js? (Using the <code>worker_threads</code> module to run JavaScript on other CPU cores).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https.developer.ibm.com/articles/l-nodejs-concurrency/" target="_blank" class="hover:underline">Node.js concurrency model (IBM)</a></li>
            <li><a href="https://nodejs.org/api/worker_threads.html" target="_blank" class="hover:underline">Node.js Docs: Worker Threads (for Parallelism)</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "Process vs. Thread",
    difficulty: "Intermediate",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "A process is an isolated program with its own memory, like opening Chrome. A thread is a lightweight unit of execution *within* a process that shares memory with other threads. My Node.js server runs as a single process, which itself has one main thread for the event loop, plus a small thread pool for I/O."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>This is a fundamental computer science concept. Let's use an analogy: a restaurant.</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li>A <strong>Process</strong> is the entire restaurant (e.g., "McDonald's").
              <ul>
                <li>It's a self-contained program (<code>node my_app.js</code>).</li>
                <li>It has its own private memory (its own kitchen, ingredients, and staff).</li>
                <li>It is fully isolated. If "McDonald's" burns down, "Burger King" (another process) is fine.</li>
              </ul>
            </li>
            <li>A <strong>Thread</strong> is a chef *inside* the restaurant.
              <ul>
                <li>It's a unit of execution *within* a process.</li>
                <li>Threads *share* memory (all chefs share the *same* kitchen and ingredients).</li>
                <li>A process can be single-threaded (one chef) or multi-threaded (many chefs).</li>
              </ul>
            </li>
          </ul>
          <p class="mt-2">A standard Node.js application is <strong>one process</strong> with <strong>one main thread</strong> (the event loop). This one chef is just very, very fast at managing tasks (non-blocking I/O).</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Comparison Table</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <div class="overflow-x-auto">
              <table class="min-w-full text-sm text-left">
                <thead class="text-xs text-gray-400 uppercase bg-gray-800">
                  <tr>
                    <th scope="col" class="py-3 px-6">Feature</th>
                    <th scope="col" class="py-3 px-6">Process</th>
                    <th scope="col" class="py-3 px-6">Thread</th>
                  </tr>
                </thead>
                <tbody class="divide-y divide-gray-700">
                  <tr class="border-b border-gray-700">
                    <td class="py-4 px-6 font-medium text-white">Memory</td>
                    <td class="py-4 px-6">Isolated (Does not share)</td>
                    <td class="py-4 px-6">Shared (within the same process)</td>
                  </tr>
                  <tr class="border-b border-gray-700">
                    <td class="py-4 px-6 font-medium text-white">Creation</td>
                    <td class="py-4 px-6">"Heavy" (slow to start)</td>
                    <td class="py-4 px-6">"Lightweight" (fast to start)</td>
                  </tr>
                  <tr class="border-b border-gray-700">
                    <td class="py-4 px-6 font-medium text-white">Fault Isolation</td>
                    <td class="py-4 px-6">High (If one process crashes, others are fine)</td>
                    <td class="py-4 px-6">Low (If one thread crashes, the whole process crashes)</td>
                  </tr>
                  <tr class="border-b border-gray-700">
                    <td class="py-4 px-6 font-medium text-white">Node.js Example</td>
                    <td class="py-4 px-6"><code>cluster</code> module</td>
                    <td class="py-4 px-6"><code>worker_threads</code> module</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>This explains Node's limitations and how to scale it. To use all 8 cores of your CPU, you can't just run <code>node server.js</code>. You must use the <code>cluster</code> module to create 8 <strong>processes</strong> (8 "restaurants") or use <code>worker_threads</code> to create new <strong>threads</strong> (more "chefs") for heavy CPU work.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>What is the Note.js 'cluster' module? (A module to create multiple child processes that can all share the same server port, allowing you to use all CPU cores).</li>
            <li>Why is sharing memory between threads hard? (It can lead to "race conditions," where two threads try to change the same value at the same time).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://www.geeksforgeeks.org/difference-between-process-and-thread/" target="_blank" class="hover:underline">Process vs. Thread (GeeksforGeeks)</a></li>
            <li><a href="https://nodejs.org/api/cluster.html" target="_blank" class="hover:underline">Node.js Docs: Cluster</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "Buffers",
    difficulty: "Advanced",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I understand Buffers are Node.js's way of handling raw binary data, which JavaScript's string type is not good at. I know they're used for tasks like reading files, handling network data, or manipulating images, where I need to work with the data byte by byte."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>A <strong>Buffer</strong> is a global object in Node.js (you don't need to <code>require</code> it). It's used to represent a fixed-size chunk of memory (a sequence of bytes) outside the V8 JavaScript engine.</p>
          <p class="mt-2">JavaScript strings are great for text (UTF-16), but they are terrible for binary data (like an image file, a TCP packet, or a zip file). Buffers are Node's solution to this. They let you interact with raw binary data directly, which is essential for I/O operations.</p>
          <p class="mt-2">When you use <code>fs.readFile()</code>, the <code>data</code> you get (if you don't specify an encoding) is a Buffer.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (Creating and using Buffers)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
// 1. Create a Buffer from a string
// Allocates 13 bytes to store "Hello World!"
const bufFromString = Buffer.from('Hello World!', 'utf8');

console.log(bufFromString); // <Buffer 48 65 6c 6c 6f 20 57 6f 72 6c 64 21> (hex values)
console.log(bufFromString.toString()); // "Hello World!"
console.log(bufFromString.length); // 13 (bytes)


// 2. Create an empty Buffer of a specific size (e.g., 10 bytes)
const bufAlloc = Buffer.alloc(10);
console.log(bufAlloc); // <Buffer 00 00 00 00 00 00 00 00 00 00> (zero-filled)

// 3. Write data to the buffer
bufAlloc.write('Hi', 'utf8');
console.log(bufAlloc); // <Buffer 48 69 00 00 00 00 00 00 00 00>
console.log(bufAlloc.toString()); // "Hi"


// 4. Buffers from file I/O (very common)
const fs = require('fs');
fs.readFile('package.json', (err, data) => {
  if (err) return console.error(err);
  
  // 'data' is a Buffer!
  console.log('Is data a Buffer?', Buffer.isBuffer(data)); // true
  console.log(data.toString('utf8').substring(0, 50) + '...'); // Shows file content
});
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>Node.js is built to interact with the operating system (files, network, etc.), which "speaks" in binary data, not just text. Buffers are the low-level "bridge" that allows your JavaScript code to handle this binary data efficiently. You need them for everything from file I/O and networking to data compression and cryptography.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>What's the difference between <code>Buffer.alloc()</code> and <code>Buffer.from()</code>? (<code>alloc</code> creates a new, empty buffer of a given size. <code>from</code> creates a buffer *from* existing data, like a string or array).</li>
            <li>What is an "encoding"? (The rule set for converting bytes to characters, e.g., 'utf8', 'hex', 'base64').</li>
            <li>Are Buffers related to Streams? (Yes, streams are a mechanism for moving data, and that data is often handled in Buffer-based chunks).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://nodejs.org/api/buffer.html" target="_blank" class="hover:underline">Node.js Docs: Buffer</a></li>
            <li><a href="https://www.freecodecamp.org/news/node-js-buffer-guide/" target="_blank" class="hover:underline">A Guide to Buffers in Node.js (freeCodeCamp)</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "Streams (Basics)",
    difficulty: "Advanced",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I use Streams to handle data I/O efficiently, especially with large files or network connections. Instead of loading an entire 1GB file into memory with 'readFile', I use a 'createReadStream' to process the data in small, manageable chunks, which is much more memory-efficient."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p><strong>Streams</strong> are one of the most powerful concepts in Node.js. They are a way to handle reading or writing data in a continuous flow (a "stream") rather than all at once. Instead of loading a 1GB file into memory (which would crash your app), you can read it chunk by chunk.</p>
          <p class="mt-2">There are four types of streams, but the two most common are:</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong>Readable Streams:</strong> A source of data you can read from (e.g., <code>fs.createReadStream</code> to read a file, or an HTTP <code>request</code>).</li>
            <li><strong>Writable Streams:</strong> A destination for data you can write to (e.g., <code>fs.createWriteStream</code> to write to a file, or an HTTP <code>response</code>).</li>
          </ul>
          <p class="mt-2">You work with streams by listening for events, like <code>'data'</code> (a chunk is ready), <code>'end'</code> (no more data), and <code>'error'</code>.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (Reading a large file)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
const fs = require('fs');
const path = require('path');

// Imagine 'large-file.txt' is 5GB.
const readStream = fs.createReadStream(path.join(__dirname, 'large-file.txt'), {
  encoding: 'utf8',
  highWaterMark: 16 * 1024 // Set chunk size to 16kb
});

let chunkCount = 0;

// 1. Listen for the 'data' event. This fires every time a chunk is ready.
readStream.on('data', (chunk) => {
  chunkCount++;
  console.log(\`--- Received chunk \${chunkCount} (\${chunk.length} bytes) ---\`);
  // console.log(chunk); // Uncomment to see the data
});

// 2. Listen for the 'end' event. This fires when the file is done.
readStream.on('end', () => {
  console.log(\`--- No more data. Total chunks: \${chunkCount} ---\`);
});

// 3. Listen for the 'error' event.
readStream.on('error', (err) => {
  console.error('An error occurred:', err.message);
});

console.log('Starting to read the stream...');
// This logs first, as the stream is async
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>Streams are the key to Node.js's high performance and low memory usage for I/O. They allow you to build applications that can process massive amounts of data without ever storing more than a tiny chunk in memory at one time. HTTP requests and responses are streams, file I/O uses streams, and data compression/encryption uses streams.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>What is <code>.pipe()</code>? (The easy way to connect a Readable stream to a Writable stream).</li>
            <li>What are Duplex and Transform streams? (Duplex is both readable/writable, like a socket. Transform is a Duplex that modifies data, like a Gzip stream).</li>
            <li>What is "backpressure"? (When a Writable stream is too slow, and the Readable stream has to pause).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://nodejs.org/api/stream.html" target="_blank" class="hover:underline">Node.js Docs: Stream</a></li>
            <li><a href="https://nodejs.org/en/learn/streaming/introduction-to-streams" target="_blank" class="hover:underline">Node.js Learn: Introduction to Streams</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "Piping Streams (`.pipe()`)",
    difficulty: "Intermediate",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "Instead of manually listening for 'data' and 'end' events, I use the '.pipe()' method to connect a readable stream directly to a writable stream. It's the cleanest way to move data, for example, from a 'createReadStream' to an 'http response' or a 'createWriteStream', and it handles backpressure automatically."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>The <code>.pipe()</code> method is a shortcut for connecting a <strong>Readable</strong> stream to a <strong>Writable</strong> stream. It's like attaching a pipe from a water source to a drain.</p>
          <p class="mt-2">It automatically does all the event handling for you:</p>
          <ul>
            <li>It listens for <code>'data'</code> on the readable stream and calls <code>.write()</code> on the writable stream.</li>
            <li>It listens for <code>'end'</code> on the readable stream and calls <code>.end()</code> on the writable stream.</li>
            <li>It automatically handles <strong>backpressure</strong>, pausing the readable stream if the writable stream gets overwhelmed.</li>
          </ul>
          <p class="mt-2">The syntax is simple: <code>readableStream.pipe(writableStream)</code>.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (Copying a file & serving a file)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
const fs = require('fs');
const http = require('http');

// --- Example 1: Efficiently copying a large file ---

const sourceFile = fs.createReadStream('large-video.mp4');
const destFile = fs.createWriteStream('video-copy.mp4');

// Instead of .on('data', ...)
sourceFile.pipe(destFile);

sourceFile.on('end', () => {
  console.log('File copy complete!');
});
sourceFile.on('error', (err) => {
  console.log('Error copying file:', err.message);
});


// --- Example 2: Serving a large file with http ---

const server = http.createServer((req, res) => {
  if (req.url === '/my-video') {
    // Create a readable stream from the file
    const videoStream = fs.createReadStream('large-video.mp4');
    
    // 'res' (the HTTP response) is a Writable Stream!
    // Pipe the file data directly to the user's browser.
    res.writeHead(200, { 'Content-Type': 'video/mp4' });
    videoStream.pipe(res);
  } else {
    res.writeHead(404).end('Not Found');
  }
});

server.listen(3000, () => console.log('Server running on port 3000...'));
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p><code>.pipe()</code> is the preferred way to work with streams. It's a single line of code that replaces a lot of complex, error-prone boilerplate. The automatic backpressure handling is a huge performance benefit, preventing your app from running out of memory when a writable stream is slow.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>Can you chain <code>.pipe()</code> calls? (Yes! <code>read.pipe(transform).pipe(write)</code>, e.g., to Gzip a file before saving it).</li>
            <li>What is the difference between this and <code>fs.readFile()</code>? (<code>readFile</code> loads the entire file into memory at once. This streams it chunk by chunk. For the HTTP example, the server memory usage stays tiny, even for a 10GB file).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://nodejs.org/api/stream.html#readablepipewritable-options" target="_blank" class="hover:underline">Node.js Docs: readable.pipe()</a></li>
            <li><a href="https://www.freecodecamp.org/news/pipe-in-node-js/" target="_blank" class="hover:underline">What is pipe() in Node.js? (freeCodeCamp)</a></li>
          </ul>
        </section>
      </div>
    `
  },

  {
    title: "File Uploads (with Multer)",
    difficulty: "Advanced",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "For file uploads, I don't parse 'multipart/form-data' myself. I use 'multer', the standard Express middleware, to handle it. I know how to configure 'multer' for a single file ('upload.single()') or multiple files, and how to access the file data from 'req.file' or 'req.files'."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>File uploads are sent from a client (like a browser) using a special <code>Content-Type</code> called <code>multipart/form-data</code>. This format is complex to parse manually.</p>
          <p class="mt-2"><strong>Multer</strong> is the standard, must-have middleware for Express to handle these uploads. It parses the incoming form, saves any files to a destination (like an <code>./uploads/</code> folder), and attaches information about the files to the <code>req</code> object (as <code>req.file</code> or <code>req.files</code>).</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (Using 'multer' for a single file)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
// --- server.js ---
// 1. Install: npm install express multer
const express = require('express');
const multer = require('multer');
const path = require('path');
const app = express();

// 2. Configure Multer's storage
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, 'uploads/'); // Save files to 'uploads/' directory
  },
  filename: (req, file, cb) => {
    // Save file with a unique name (timestamp + original name)
    cb(null, Date.now() + '-' + file.originalname);
  }
});

// 3. Initialize Multer
const upload = multer({ storage: storage });

// 4. Create an 'uploads' directory if it doesn't exist
const fs = require('fs');
if (!fs.existsSync('uploads')) {
  fs.mkdirSync('uploads');
}

// 5. Create a route that uses the middleware
// 'avatar' is the 'name' attribute of the <input type="file" name="avatar">
app.post('/profile-upload', upload.single('avatar'), (req, res) => {
  // 'req.file' is the 'avatar' file
  // 'req.body' will hold the text fields, if any
  
  if (!req.file) {
    return res.status(400).send('No file uploaded.');
  }

  console.log('File details:', req.file);
  res.json({
    message: 'File uploaded successfully!',
    filename: req.file.filename,
    path: req.file.path
  });
});

app.listen(3000, () => console.log('Server listening on port 3000...'));

// --- public/index.html (Example client form) ---
// &lt;form action="/profile-upload" method="POST" enctype="multipart/form-data"&gt;
//   &lt;h2&gt;Upload Profile Picture&lt;/h2&gt;
//   &lt;input type="file" name="avatar" /&gt;
//   &lt;button type="submit"&gt;Upload&lt;/button&gt;
// &lt;/form&gt;
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>Handling file uploads is a core requirement for almost any modern application (profile pictures, document sharing, etc.). Using <code>multer</code> correctly is a non-negotiable skill for an Express developer. It handles parsing, streaming, and saving files, which is extremely difficult to do from scratch.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>How would you handle multiple files? (<code>upload.array('photos', 10)</code>).</li>
            <li>How can you restrict file types? (Using the <code>fileFilter</code> option in <code>multer({ ... })</code>).</li>
            <li>Where is the file data in <code>req.file</code>? (<code>req.file</code> is an object with info like <code>filename</code>, <code>path</code>, <code>mimetype</code>, and <code>size</code>).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://github.com/expressjs/multer" target="_blank" class="hover:underline">Multer NPM (Official Docs)</a></li>
            <li><a href="https://www.digitalocean.com/community/tutorials/how-to-handle-file-uploads-in-express-using-multer" target="_blank" class="hover:underline">How To Handle File Uploads in Express (DigitalOcean)</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "Read File and Write file",
    difficulty: "Intermediate",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I know the 'fs' module is for file system operations. I use the async methods 'fs.readFile' and 'fs.writeFile' with an error-first callback, as they are non-blocking. I only use the sync versions, 'readFileSync' and 'writeFileSync', at the start of a script for loading config."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>The <code>fs</code> (File System) module is a core Node.js module for interacting with the file system.</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong><code>fs.readFile(path, [options], callback)</code>:</strong>
              <ul>
                <li><strong>Asynchronous.</strong> Reads the *entire* file into memory and passes its contents (as a Buffer or string) to the callback.</li>
                <li>The callback is an "error-first" callback: <code>(err, data) => { ... }</code>.</li>
              </ul>
            </li>
            <li><strong><code>fs.writeFile(path, data, [options], callback)</code>:</strong>
              <ul>
                <li><strong>Asynchronous.</strong> Writes <code>data</code> to a file, replacing it if it exists.</li>
                <li>The callback is <code>(err) => { ... }</code>.</li>
              </ul>
            </li>
            <li><strong><code>...Sync()</code> versions:</strong> <code>fs.readFileSync()</code> and <code>fs.writeFileSync()</code> are the synchronous, blocking versions. They are fine for simple scripts but should be avoided inside a web server as they block the event loop.</li>
          </ul>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (Async Read/Write)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
const fs = require('fs');
const path = require('path');

const filePath = path.join(__dirname, 'greetings.txt');
const newFilePath = path.join(__dirname, 'new-file.txt');

// 1. Asynchronous Write
fs.writeFile(filePath, 'Hello from Node.js!', 'utf8', (err) => {
  if (err) {
    return console.error('Error writing file:', err.message);
  }
  console.log('File written successfully.');

  // 2. Asynchronous Read (chained after write)
  // 'utf8' encoding returns a string, otherwise it's a Buffer
  fs.readFile(filePath, 'utf8', (err, data) => {
    if (err) {
      return console.error('Error reading file:', err.message);
    }
    console.log('File content:', data); // "Hello from Node.js!"

    // 3. Example of Sync Read (Used for initial config)
    // This blocks, but it's okay here at the top level
    try {
      const config = fs.readFileSync('package.json', 'utf8');
      console.log('Loaded config file.');
    } catch (err) {
      console.error('Could not load config', err.message);
    }
  });
});

console.log('Writing file...'); // This logs *before* "File written successfully."
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>This is a fundamental I/O operation. Understanding the async vs. sync versions is critical. Using <code>readFileSync</code> inside an Express route is a major performance bottleneck, as it will block your entire server from handling other requests until the file is read.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>What happens if you don't specify 'utf8' when reading? (You get a Buffer).</li>
            <li>What's the difference between <code>writeFile</code> and <code>appendFile</code>? (<code>writeFile</code> overwrites the file, <code>appendFile</code> adds to the end).</li>
            <li>What if the file is 10GB? (Don't use <code>readFile</code>! Use <code>fs.createReadStream</code> to stream it).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://nodejs.org/api/fs.html#fsreadfilepath-options-callback" target="_blank" class="hover:underline">Node.js Docs: fs.readFile()</a></li>
            <li><a href="https://nodejs.org/api/fs.html#fswritefilepath-data-options-callback" target="_blank" class="hover:underline">Node.js Docs: fs.writeFile()</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "File System Operations: `stat`, `unlink`, `existsSync`",
    difficulty: "Intermediate",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I use 'fs.stat' to get file metadata, like 'stats.isDirectory()' or 'stats.size'. I use 'fs.unlink' to delete a file, and 'fs.existsSync' for a simple, synchronous check to see if a file or directory exists before I try to operate on it."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>These are common "utility" functions in the <code>fs</code> module.</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong><code>fs.stat(path, callback)</code>:</strong>
              <ul>
                <li><strong>Asynchronous.</strong> Gets "stats" (metadata) about a file or directory.</li>
                <li>The callback <code>(err, stats)</code> gives you a <code>stats</code> object. You can check <code>stats.isFile()</code>, <code>stats.isDirectory()</code>, <code>stats.size</code> (in bytes), <code>stats.mtime</code> (last modified time), etc.</li>
              </ul>
            </li>
            <li><strong><code>fs.unlink(path, callback)</code>:</strong>
              <ul>
                <li><strong>Asynchronous.</strong> Deletes a file. The name "unlink" comes from Unix.</li>
                <li>The callback is <code>(err) => { ... }</code>.</li>
              </ul>
            </li>
            <li><strong><code>fs.existsSync(path)</code>:</strong>
              <ul>
                <li><strong>Synchronous.</strong> Returns <code>true</code> or <code>false</code> if the path exists.</li>
                <li>This is one of the few <code>Sync</code> methods that is acceptable to use in server code, because it's fast and often needed right before an async operation (e.g., "check if <code>uploads</code> folder exists before making it").</li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (Check, Stat, and Unlink)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
const fs = require('fs');
const path = require('path');

const tempFilePath = path.join(__dirname, 'temp-file.txt');

// 1. Check if a file exists (SYNC)
if (fs.existsSync(tempFilePath)) {
  console.log('File already exists. Deleting it...');
  
  // 2. Delete the file (ASYNC)
  fs.unlink(tempFilePath, (err) => {
    if (err) return console.error('Could not delete file:', err.message);
    console.log('File deleted.');
    createAndStatFile();
  });
} else {
  createAndStatFile();
}

function createAndStatFile() {
  fs.writeFile(tempFilePath, 'This is temporary', (err) => {
    if (err) return console.error('Write failed:', err.message);
    
    // 3. Get metadata for the file (ASYNC)
    fs.stat(tempFilePath, (err, stats) => {
      if (err) return console.error('Stat failed:', err.message);
      
      console.log('--- File Stats ---');
      console.log('Is it a file?', stats.isFile()); // true
      console.log('Is it a directory?', stats.isDirectory()); // false
      console.log('File size (bytes):', stats.size);
      console.log('Last modified:', stats.mtime);
    });
  });
}
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>These are the building blocks of file management. You need <code>stat</code> to check permissions or file types, <code>unlink</code> to clean up temporary files (like after a file upload), and <code>existsSync</code> for safe, defensive checks before creating directories or writing files.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>How would you delete a directory? (<code>fs.rmdir()</code> for empty ones, or <code>fs.rm(path, { recursive: true })</code> for non-empty).</li>
            <li>What's the difference between <code>fs.stat</code> and <code>fs.lstat</code>? (<code>stat</code> follows symbolic links, <code>lstat</code> gives stats about the link itself).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://nodejs.org/api/fs.html#fsstatpath-options-callback" target="_blank" class="hover:underline">Node.js Docs: fs.stat()</a></li>
            <li><a href="https://nodejs.org/api/fs.html#fsunlinkpath-callback" target="_blank" class="hover:underline">Node.js Docs: fs.unlink()</a></li>
            <li><a href="https://nodejs.org/api/fs.html#fsexistssyncpath" target="_blank" class="hover:underline">Node.js Docs: fs.existsSync()</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "Create or Remove Directory",
    difficulty: "Intermediate",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I use 'fs.mkdir()' to create a directory. If I need to create nested directories, like 'a/b/c', I use the '{ recursive: true }' option. To remove a directory, I use 'fs.rmdir()' for empty ones, or 'fs.rm()' with '{ recursive: true }' for non-empty ones."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>The <code>fs</code> module provides methods for managing directories (folders).</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong><code>fs.mkdir(path, [options], callback)</code>:</strong>
              <ul>
                <li><strong>Asynchronous.</strong> Creates a new directory.</li>
                <li><strong>Options:</strong> <code>{ recursive: true }</code> is essential. It will create parent directories as needed (like <code>mkdir -p</code> in bash) and won't throw an error if the directory already exists.</li>
              </ul>
            </li>
            <li><strong><code>fs.rmdir(path, [options], callback)</code>:</strong>
              <ul>
                <li><strong>Asynchronous.</strong> Removes a directory. This will fail if the directory is not empty.</li>
              </ul>
            </li>
            <li><strong><code>fs.rm(path, [options], callback)</code>:</strong> (Modern)
              <ul>
                <li><strong>Asynchronous.</strong> The "new" way to remove files or directories.</li>
                <li>To remove a non-empty directory, use: <code>fs.rm(path, { recursive: true, force: true }, cb)</code>.</li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (Recursive Create and Remove)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
const fs = require('fs');
const path = require('path');

// This path is nested: 'data' contains 'logs'
const nestedDir = path.join(__dirname, 'data', 'logs');

// 1. Create a nested directory (ASYNC)
fs.mkdir(nestedDir, { recursive: true }, (err) => {
  if (err) return console.error('Could not create dir:', err.message);
  
  console.log('Directory created:', nestedDir);

  // 2. Write a file inside it
  const logFile = path.join(nestedDir, 'app.log');
  fs.writeFile(logFile, 'Log entry', (err) => {
    if (err) return console.error('Could not write log:', err.message);

    console.log('Log file created.');

    // 3. Remove the non-empty parent directory (ASYNC)
    const dirToRemove = path.join(__dirname, 'data');
    fs.rm(dirToRemove, { recursive: true, force: true }, (err) => {
      if (err) return console.error('Could not remove dir:', err.message);
      
      console.log('Recursively removed:', dirToRemove);
    });
  });
});
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>This is essential for setup and cleanup. You use <code>mkdir</code> to ensure your <code>uploads</code> or <code>logs</code> directories exist when your server starts. You use <code>rm</code> or <code>rmdir</code> to clean up temporary directories or user data upon deletion.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>How would you read the contents of a directory? (<code>fs.readdir(path, callback)</code>, which gives you an array of filenames).</li>
            <li>What's the difference between <code>fs.rmdir</code> and <code>fs.rm</code>? (<code>rmdir</code> is older and only works on empty directories. <code>rm</code> is newer, more powerful, and can remove files or non-empty directories with the <code>recursive</code> flag).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://nodejs.org/api/fs.html#fsmkdirpath-options-callback" target="_blank" class="hover:underline">Node.js Docs: fs.mkdir()</a></li>
            <li><a href="https://nodejs.org/api/fs.html#fsrmpath-options-callback" target="_blank" class="hover:underline">Node.js Docs: fs.rm()</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "File Permissions",
    difficulty: "Advanced",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I know file permissions are handled by the OS and are based on 'read', 'write', and 'execute' for the 'user', 'group', and 'other'. I can check permissions using 'fs.stat()' to get the 'mode' (like 0o755), and I can change them using 'fs.chmod()'."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>File Permissions control who can read, write, or execute a file. This is a core concept of Linux/macOS/Unix operating systems, which Node.js runs on.</p>
          <p class="mt-2">Permissions are represented by an <strong>octal (base-8) number</strong>, like <code>0o755</code>.</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li>The number is made of 3 digits: (Owner)(Group)(Others)</li>
            <li>Each digit is a sum of permissions:
              <ul>
                <li><strong>4</strong> = Read</li>
                <li><strong>2</strong> = Write</li>
                <li><strong>1</strong> = Execute</li>
              </ul>
            </li>
          </ul>
          <p class="mt-2"><strong>Common Modes:</strong></p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><code>0o755</code> (rwx r-x r-x): Owner can do anything (4+2+1=7). Group/Others can read/execute (4+1=5). (Common for directories).</li>
            <li><code>0o644</code> (rw- r-- r--): Owner can read/write (4+2=6). Group/Others can only read (4). (Common for files).</li>
          </ul>
          <p class="mt-2">In Node.js, you use <code>fs.stat</code> to read the mode, and <code>fs.chmod</code> to change it.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (Check and Set Permissions)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
const fs = require('fs');
const path = require('path');

const scriptFile = path.join(__dirname, 'my-script.sh');

// Create a dummy script file
fs.writeFile(scriptFile, '#!/bin/bash\necho "Hello"', (err) => {
  if (err) return console.error(err);
  console.log('Script created.');

  // 1. Check current permissions
  fs.stat(scriptFile, (err, stats) => {
    if (err) return console.error(err);
    // .toString(8) converts the mode number to an octal string
    console.log('Original mode:', (stats.mode & 0o777).toString(8)); // e.g., "644"

    // 2. Make the file executable for the owner
    // We want 744 (rwx r-- r--)
    fs.chmod(scriptFile, 0o744, (err) => {
      if (err) return console.error('chmod failed:', err.message);
      
      console.log('Mode changed to 744.');

      // 3. Verify the new permissions
      fs.stat(scriptFile, (err, newStats) => {
        console.log('New mode:', (newStats.mode & 0o777).toString(8)); // "744"
      });
    });
  });
});
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>Permissions are critical for security and operations. If your Node.js app generates a script, it must use <code>fs.chmod</code> to make it executable. If it creates a user's data file, it should set permissions (e.g., <code>0o600</code>, "read/write for owner only") to prevent other users on the system from reading it.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>What is <code>(stats.mode & 0o777)</code> doing? (The full <code>mode</code> contains extra data. Bitwise-ANDing with <code>0o777</code> isolates *only* the permission bits).</li>
            <li>How do you change file ownership? (<code>fs.chown()</code>).</li>
            <li>How does this apply to Windows? (It doesn't, really. Windows has a different, more complex ACL system. Node's <code>fs.chmod</code> has limited effect on Windows).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://nodejs.org/api/fs.html#fschmodpath-mode-callback" target="_blank" class="hover:underline">Node.js Docs: fs.chmod()</a></li>
            <li><a href="https://nodejs.org/api/fs.html#statsmode" target="_blank" class="hover:underline">Node.js Docs: stats.mode</a></li>
            <li><a href="https://www.linux.com/tutorials/understanding-linux-file-permissions/" target="_blank" class="hover:underline">Understanding Linux File Permissions</a></li>
          </ul>
        </section>
      </div>
    `
  }

  

  {
    title: "Authentication vs. Authorization",
    difficulty: "Intermediate",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I understand the difference: Authentication is 'who are you?' (e.g., logging in with a password), which answers with a 401. Authorization is 'what are you allowed to do?' (e.g., checking if a user is an admin), which answers with a 403."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>These two security concepts are the foundation of user management, but they are not the same.</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong>Authentication (AuthN):</strong>
              <ul>
                <li><strong>The Question:</strong> "Who are you?"</li>
                <li><strong>The Process:</strong> Verifying a user's identity. This is the "login" step. The user provides credentials (like a username/password or a token) to prove they are who they claim to be.</li>
                <li><strong>The Result:</strong> The system knows *who* the user is (e.g., <code>req.user = { id: 123, role: 'user' }</code>).</li>
                <li><strong>HTTP Status Code (Failure):</strong> <code>401 Unauthorized</code> (You are not logged in).</li>
              </ul>
            </li>
            <li><strong>Authorization (AuthZ):</strong>
              <ul>
                <li><strong>The Question:</strong> "Are you allowed to do this?"</li>
                <li><strong>The Process:</strong> Checking a user's *permissions* after they have been authenticated. This happens on almost every request.</li>
                <li><strong>The Result:</strong> The system grants or denies access to a specific resource (e.g., "Yes, this user is an 'admin' and can access <code>/admin</code>").</li>
                <li><strong>HTTP Status Code (Failure):</strong> <code>403 Forbidden</code> (You are logged in, but you don't have permission).</li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (Middleware for AuthN and AuthZ)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
// --- 1. Authentication Middleware (Checks "Who are you?") ---
// (This is a simplified example of token/session lookup)
const authenticate = (req, res, next) => {
  const token = req.headers['authorization'];
  if (token === 'user-token-123') {
    req.user = { id: 123, role: 'user' };
    next();
  } else if (token === 'admin-token-456') {
    req.user = { id: 456, role: 'admin' };
    next();
  } else {
    // 401 Unauthorized: You are not logged in or have no token
    res.status(401).json({ error: 'Authentication required.' });
  }
};

// --- 2. Authorization Middleware (Checks "What can you do?") ---
const authorizeAdmin = (req, res, next) => {
  if (req.user && req.user.role === 'admin') {
    next();
  } else {
    // 403 Forbidden: You are logged in, but not an admin
    res.status(403).json({ error: 'You do not have permission.' });
  }
};

// --- Using them in routes ---
app.use(authenticate); // Authenticate *all* requests after this

// This route is fine for any authenticated user
app.get('/profile', (req, res) => {
  res.json(req.user);
});

// This route requires both authentication AND admin authorization
app.get('/admin-panel', authorizeAdmin, (req, res) => {
  res.json({ message: 'Welcome to the admin panel' });
});
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>You cannot build a secure application without implementing both. Authentication is the gateway, and Authorization is the set of locks on every door inside. Confusing them leads to massive security holes, like letting a logged-in user see another user's private data.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>What is the difference between 401 and 403? (401: Not logged in. 403: Logged in, but not allowed).</li>
            <li>What are common authentication strategies? (Sessions/cookies, JSON Web Tokens (JWT), OAuth).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://www.auth0.com/docs/get-started/identity-fundamentals/authentication-and-authorization" target="_blank" class="hover:underline">Auth0: Authentication vs. Authorization</a></li>
            <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/401" target="_blank" class="hover:underline">MDN: 401 Unauthorized</a></li>
            <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/403" target="_blank" class="hover:underline">MDN: 403 Forbidden</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "Cookies & Sessions",
    difficulty: "Intermediate",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I use 'express-session' to implement session-based authentication. The middleware stores session data on the server (like in a database) and gives the client a cookie with a unique Session ID. On subsequent requests, 'cookie-parser' reads this cookie, and 'express-session' uses the ID to retrieve the user's data."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>HTTP is "stateless," meaning each request is independent. To remember who a user is, we use <strong>sessions</strong>.</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong>Cookie:</strong> A small piece of data the server sends to the browser. The browser stores it and sends it back with *every* request to that server.</li>
            <li><strong>Session:</strong> A mechanism to store user data *on the server*.</li>
            <li><strong>How they work together:</strong>
              <ol class="list-decimal list-inside ml-4 mt-1">
                <li>A user logs in.</li>
                <li>The server creates a "session" (e.g., <code>{ userId: 123 }</code>) and stores it (in memory, or a database).</li>
                <li>The server generates a unique Session ID (e.g., <code>'abc123xyz'</code>) and sends it to the client as a <strong>cookie</strong>.</li>
                <li>On the next request, the client sends the cookie (<code>'abc123xyz'</code>) back.</li>
                <li>The server reads the ID, finds the matching session data, and knows the user is <code>{ userId: 123 }</code>.</li>
              </ol>
            </li>
          </ul>
          <p class="mt-2"><code>cookie-parser</code> is a middleware that parses cookie headers. <code>express-session</code> is a middleware that manages the entire session process.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (Using express-session)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
// 1. Install: npm install express-session cookie-parser
const express = require('express');
const session = require('express-session');
const cookieParser = require('cookie-parser');
const app = express();

app.use(cookieParser());
app.use(session({
  secret: 'a-very-strong-secret-key', // Used to sign the session ID cookie
  resave: false,
  saveUninitialized: false,
  cookie: { secure: false, maxAge: 60000 } // 'secure: true' for HTTPS
}));

// 2. Login route
app.get('/login', (req, res) => {
  // In a real app, you'd check a password here
  // We attach data to req.session, and the middleware handles the rest
  req.session.user = { id: 123, username: 'alice' };
  res.send('You are logged in');
});

// 3. Profile route (checks session)
app.get('/profile', (req, res) => {
  if (req.session.user) {
    res.send(\`Welcome, \${req.session.user.username}\`);
  } else {
    res.status(401).send('You are not logged in');
  }
});

// 4. Logout route
app.get('/logout', (req, res) => {
  req.session.destroy((err) => {
    if (err) return res.send('Error logging out');
    res.clearCookie('connect.sid'); // 'connect.sid' is the default cookie name
    res.send('You are logged out');
  });
});
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
        <p>This is the classic, "stateful" way to handle authentication. It's robust and secure (since the user data *never* leaves the server). While stateless JWTs are also popular, understanding session/cookie auth is essential.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>Where is the session data stored by default? (In memory, which is not for production. You'd use a store like <code>connect-mongo</code> or <code>connect-redis</code>).</li>
            <li>What is the <code>secret</code> used for? (To cryptographically sign the session ID, so the client can't tamper with it).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://github.com/expressjs/session" target="_blank" class="hover:underline">express-session NPM Package</a></li>
            <li><a href="https://github.com/expressjs/cookie-parser" target="_blank" class="hover:underline">cookie-parser NPM Package</a></li>
            <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies" target="_blank" class="hover:underline">MDN: HTTP Cookies</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "Cookie Attributes",
    difficulty: "Advanced",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I know the key security attributes for cookies. I set 'httpOnly: true' to prevent JavaScript access (XSS), 'secure: true' to ensure the cookie is only sent over HTTPS, and 'SameSite=Strict' or 'Lax' to mitigate cross-site request forgery (CSRF) attacks."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>When setting a cookie, you can add attributes that give the browser strict rules about how to handle it. These are critical for security.</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong><code>httpOnly: true</code>:</strong>
              <ul>
                <li><strong>Effect:</strong> The cookie <strong>cannot</strong> be accessed by client-side JavaScript (<code>document.cookie</code> will not show it).</li>
                <li><strong>Security:</strong> This is your #1 defense against <strong>Cross-Site Scripting (XSS)</strong> attacks. If an attacker injects a script, they can't steal the session cookie.</li>
              </ul>
            </li>
            <li><strong><code>secure: true</code>:</strong>
              <ul>
                <li><strong>Effect:</strong> The browser will *only* send the cookie over an <code>HTTPS</code> connection.</li>
                <li><strong>Security:</strong> Prevents "man-in-the-middle" attacks from intercepting the cookie over an unencrypted <code>HTTP</code> connection.</li>
              </ul>
            </li>
            <li><strong><code>SameSite='Strict' | 'Lax' | 'None'</code>:</strong>
              <ul>
                <li><strong>Effect:</strong> Controls whether a cookie is sent with cross-site requests.</li>
                <li><strong>Security:</strong> This is your #1 defense against <strong>Cross-Site Request Forgery (CSRF)</strong>.
                  <ul>
                    <li><code>Strict</code>: Only send cookie for requests *from the same site*.</li>
                    <li><code>Lax</code>: (Default in modern browsers) Send cookie on same-site requests and top-level navigation (e.g., clicking a link).</li>
                    <li><code>None</code>: Send cookie on all requests (requires <code>secure: true</code>).</li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><strong><code>maxAge</code> / <code>expires</code>:</strong> Controls how long the cookie lives. <code>maxAge</code> is in milliseconds. If not set, it's a "session cookie" and is deleted when the browser closes.</li>
          </ul>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (Setting a secure cookie)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
const express = require('express');
const app = express();
const cookieParser = require('cookie-parser');
app.use(cookieParser());

// This would be set in an env variable
const IS_PRODUCTION = process.env.NODE_ENV === 'production';

// Example: Setting a cookie manually
app.get('/set-cookie', (req, res) => {
  res.cookie('myToken', 'a-secret-value-123', {
    maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days
    httpOnly: true,                 // Cannot be read by JS
    secure: IS_PRODUCTION,          // Only send over HTTPS
    sameSite: 'Strict'              // Prevent CSRF
  });
  res.send('Cookie has been set!');
});

// 'express-session' sets these for you in its 'cookie' option:
app.use(session({
  // ...
  cookie: {
    maxAge: 7 * 24 * 60 * 60 * 1000,
    httpOnly: true,
    secure: IS_PRODUCTION,
    sameSite: 'Strict'
  }
}));
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>These are not optional. Failing to set <code>httpOnly</code> and <code>SameSite</code> on your session cookies is a major security vulnerability that can lead to your users' accounts being hijacked. Modern security scanners will flag these as high-priority issues.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>What is XSS? What is CSRF? (XSS is an attacker running scripts in your user's browser. CSRF is an attacker tricking a user into making a request they didn't intend).</li>
            <li>Why would you ever set <code>SameSite='None'</code>? (For third-party embedded services, like a chat widget, that need their cookies to work across domains).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#security" target="_blank" class="hover:underline">MDN: Cookie Security</a></li>
            <li><a href="https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/06-Session_Management_Testing/02-Testing_for_Cookie_Attributes" target="_blank" class="hover:underline">OWASP: Cookie Attributes</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "Browser Storages: `localStorage` vs. `sessionStorage` vs. Cookies",
    difficulty: "Intermediate",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I know the differences: 'localStorage' persists data in the browser until it's cleared, 'sessionStorage' clears when the tab closes, and 'Cookies' are sent to the server with every request. For auth tokens, I'd never store them in 'localStorage' due to XSS. I'd use an 'httpOnly' cookie."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>These are three ways to store data in a user's browser, but they have different purposes, lifespans, and security implications.</p>
          <p class="mt-2"><strong>Cookies:</strong></p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong>Storage Limit:</strong> Small (~4KB).</li>
            <li><strong>Accessibility:</strong> Server (via HTTP headers) and Client (<code>document.cookie</code>, unless <code>httpOnly</code>).</li>
            <li><strong>Persistence:</strong> Defined by <code>expires</code> or <code>maxAge</code>.</li>
            <li><strong>Sent to Server:</strong> <strong>Yes, on every single request.</strong></li>
            <li><strong>Use Case:</strong> Storing session IDs or tokens that the server *needs* to know.</li>
          </ul>
          <p class="mt-2"><strong><code>localStorage</code>:</strong></p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong>Storage Limit:</strong> Large (~5-10MB).</li>
            <li><strong>Accessibility:</strong> Client-side JavaScript only (<code>localStorage.setItem(...)</code>).</li>
            <li><strong>Persistence:</strong> Permanent. Lasts until the user clears their browser cache.</li>
            <li><strong>Sent to Server:</strong> <strong>No, never.</strong></li>
            <li><strong>Use Case:</strong> Storing non-sensitive user preferences, a cached profile, or app state.</li>
          </ul>
          <p class="mt-2"><strong><code>sessionStorage</code>:</strong></p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong>Storage Limit:</strong> Large (~5-10MB).</li>
            <li><strong>Accessibility:</strong> Client-side JavaScript only (<code>sessionStorage.setItem(...)</code>).</li>
            <li><strong>Persistence:</strong> <strong>Per-tab.</strong> Data is cleared when the *tab* is closed.</li>
            <li><strong>Sent to Server:</strong> <strong>No, never.</strong></li>
            <li><strong>Use Case:</strong> Storing temporary data for a single user session, like form data, that shouldn't persist.</li>
          </ul>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (JavaScript on the Client-Side)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
// This is code you would run in the BROWSER's console, not Node.js

// --- localStorage ---
// It will stay after you close and re-open the browser
localStorage.setItem('user-theme', 'dark');
console.log(localStorage.getItem('user-theme')); // "dark"

// --- sessionStorage ---
// It will be gone if you close this tab
sessionStorage.setItem('form-draft', 'This is my text...');
console.log(sessionStorage.getItem('form-draft')); // "This is my text..."

// --- Cookies ---
// (Can be set by server or client, unless httpOnly)
document.cookie = "username=alice; max-age=3600";
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p><strong>Security.</strong> Storing a session token or JWT in <code>localStorage</code> is a massive security risk. It's easily stolen via an XSS attack. The *only* secure, modern way to store auth tokens on the web is in an <code>httpOnly</code>, <code>secure</code>, <code>SameSite</code> cookie. This is a critical concept for a backend developer.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>Why is <code>localStorage</code> bad for auth tokens? (Vulnerable to XSS. Any script can read <code>localStorage.getItem('token')</code> and send it to an attacker).</li>
            <li>Why are cookies "bad" for non-auth data? (Because they are sent with *every* request, bloating the request headers).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API" target="_blank" class="hover:underline">MDN: Web Storage API</a></li>
            <li><a href="https://owasp.org/www-project-cheat-sheets/cheatsheets/HTML5_Security_Cheat_Sheet.html#local-storage" target="_blank" class="hover:underline">OWASP: Local Storage Security</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "Hashing vs. Encryption",
    difficulty: "Advanced",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I know hashing and encryption are different. Hashing ('bcrypt', 'crypto.createHash') is a one-way process used to verify data, which is perfect for passwords. Encryption ('crypto.createCipheriv') is a two-way process that can be reversed, which is for protecting data you need to read later, like a user's API key."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>Both are forms of cryptography, but they have opposite goals.</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong>Hashing (One-Way):</strong>
              <ul>
                <li><strong>What:</strong> Transforms data into a unique, fixed-size string (a "hash").</li>
                <li><strong>Key Feature:</strong> <strong>You cannot reverse it.</strong> You can't get the original data back from the hash.</li>
                <li><strong>How to use:</strong> To *verify*. You hash a user's password, store the hash. When they log in, you hash their new attempt and *compare the hashes*.</li>
                <li><strong>Tools:</strong> <code>bcrypt</code> (preferred for passwords), <code>crypto.createHash('sha256')</code>.</li>
              </ul>
            </li>
            <li><strong>Encryption (Two-Way):</strong>
              <ul>
                <li><strong>What:</strong> Transforms data into an unreadable format ("ciphertext").</li>
                <li><strong>Key Feature:</strong> <strong>You can reverse it</strong> (decrypt) *if* you have the correct key.</li>
                <li><strong>How to use:</strong> To *protect* data that you need to use later (e.g., credit card info, API keys, secret messages).</li>
                <li><strong>Tools:</strong> <code>crypto.createCipheriv()</code> / <code>crypto.createDecipheriv()</code>.</li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (Using bcrypt for Passwords)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
// 1. Install: npm install bcrypt
const bcrypt = require('bcrypt');

async function testPassword() {
  const myPassword = 'MySuperPassword123';
  
  // --- HASHING (Storing the password) ---
  // A "salt" is random data added to the hash to make it unique
  const saltRounds = 10;
  const hashedPassword = await bcrypt.hash(myPassword, saltRounds);
  
  console.log('Original Password:', myPassword);
  console.log('Hashed Password:', hashedPassword);
  // Hashed: $2b$10$fA... (a long, random-looking string)

  // --- COMPARING (Logging in) ---
  const isMatch = await bcrypt.compare(myPassword, hashedPassword);
  console.log('Passwords match?', isMatch); // true

  const isBadMatch = await bcrypt.compare('WrongPassword', hashedPassword);
  console.log('Bad passwords match?', isBadMatch); // false
}

testPassword();
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>This is the most important security concept. You <strong>NEVER, EVER</strong> store plain-text passwords. You must always hash them. Using encryption for passwords is also wrong (if your key leaks, all passwords leak). Using the right tool (hashing for passwords, encryption for data) is critical.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>Why is <code>bcrypt</code> better than <code>sha256</code> for passwords? (<code>bcrypt</code> is intentionally *slow* and "key-stretching," which makes it much harder to brute-force).</li>
            <li>What is "salt" and why is it important? (It ensures two users with the same password get different hashes, defeating "rainbow table" attacks).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://github.com/kelektiv/bcrypt.js" target="_blank" class="hover:underline">bcrypt.js NPM Package</a></li>
            <li><a href="https://nodejs.org/api/crypto.html" target="_blank" class="hover:underline">Node.js Docs: crypto module</a></li>
            <li><a href="https://auth0.com/blog/hashing-in-action-understanding-bcrypt/" target="_blank" class="hover:underline">Auth0: Hashing in Action (bcrypt)</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "Environment Variables",
    difficulty: "Beginner",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I use environment variables for all configuration and secrets, like API keys or database URLs. I access them using 'process.env.MY_VAR' and use a '.env' file with the 'dotenv' package in development to load them, which I always add to '.gitignore'."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p><strong>Environment Variables</strong> are variables that live *outside* your code, in the operating system's environment. This is the correct place to store configuration that changes between environments (development, production) and, most importantly, <strong>secrets</strong>.</p>
          <p class="mt-2">You should <strong>NEVER</strong> hard-code API keys, database passwords, or secret keys in your source code.</p>
          <p class="mt-2"><strong>How to use them:</strong></p>
          <ol class="list-decimal list-inside ml-4 mt-1">
            <li>In production, you set them on the server (e.g., in Heroku, AWS, or with <code>export DB_USER="prod"</code>).</li>
            <li>In development, you create a <code>.env</code> file.</li>
            <li>Use the <code>dotenv</code> package to read the <code>.env</code> file and add its variables to <code>process.env</code>.</li>
            <li>Access all variables via the <code>process.env</code> global object.</li>
          </ol>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (Using dotenv)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
// --- File: .env ---
// (This file is in the root of your project)
PORT=3000
DB_HOST=localhost
DB_USER=my_dev_user
API_KEY=my-secret-key-12345

// --- File: .gitignore ---
.env
node_modules

// --- File: server.js ---
// 1. Install: npm install dotenv
// 2. Load .env file (as early as possible!)
require('dotenv').config();

const express = require('express');
const app = express();

// 3. Access variables from process.env
const port = process.env.PORT || 8080;
const dbUser = process.env.DB_USER;
const apiKey = process.env.API_KEY;

app.get('/', (req, res) => {
  res.send(\`Hello! Running on port \${port}. DB user is \${dbUser}.\`);
});

app.listen(port, () => {
  console.log(\`Server starting on port \${port}\`);
});
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>This is a fundamental security and operational practice. It allows you to:
          1.  <strong>Keep secrets safe:</strong> By putting <code>.env</code> in <code>.gitignore</code>, you never commit secrets to source control.
          2.  <strong>Be flexible:</strong> Your production server can use a different port, database, and API key just by setting different environment variables, without any code changes.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>Why must <code>.env</code> be in <code>.gitignore</code>? (To prevent secrets from being leaked to GitHub).</li>
            <li>What is <code>process.env.NODE_ENV</code>? (The most common variable, set to 'production' or 'development' to change app behavior).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://github.com/motdotla/dotenv" target="_blank" class="hover:underline">dotenv NPM Package</a></li>
            <li><a href="https://nodejs.org/api/process.html#processenv" target="_blank" class="hover:underline">Node.js Docs: process.env</a></li>
            <li><a href="https://12factor.net/config" target="_blank" class="hover:underline">The 12-Factor App: Config</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "Third-Party Middleware: `morgan`, `helmet`",
    difficulty: "Beginner",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I'm familiar with common third-party middleware. I use 'morgan' for HTTP request logging, which is great for development, and 'helmet' to set a number of important HTTP security headers to protect my app from common web vulnerabilities."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>These are two of the most common and essential third-party middleware packages you will add to almost every Express project.</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong><code>morgan</code>:</strong>
              <ul>
                <li><strong>Purpose:</strong> HTTP request logger.</li>
                <li><strong>Effect:</strong> It automatically logs information about every incoming request to your console (e.g., <code>GET / 200 5ms</code>). This is invaluable for debugging during development.</li>
              </ul>
            </li>
            <li><strong><code>helmet</code>:</strong>
              <ul>
                <li><strong>Purpose:</strong> A collection of 15+ smaller middleware functions that set HTTP headers to improve security.</li>
                <li><strong>Effect:</strong> It helps protect your app from common attacks like XSS, clickjacking, and others by setting headers like <code>Content-Security-Policy</code>, <code>X-Content-Type-Options</code>, etc.</li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (Using both)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
// 1. Install: npm install morgan helmet
const express = require('express');
const morgan = require('morgan');
const helmet = require('helmet');
const app = express();

// 2. Use Helmet (as early as possible for security)
app.use(helmet());

// 3. Use Morgan for logging
// 'dev' is a pre-defined format that's concise and colorful
app.use(morgan('dev'));

// --- Your other middleware and routes ---
app.use(express.json());

app.get('/', (req, res) => {
  res.send('Hello, secure world!');
});

app.post('/api', (req, res) => {
  res.json({ message: 'ok' });
});

app.listen(3000, () => console.log('Server running...'));
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Terminal Commands</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-bash">
# Run the server
$ node server.js
# Output: Server running...

# Make a request
$ curl http://localhost:3000/
# The server console will show a log from Morgan:
# GET / 200 1.234 ms - 20

# Make another request
$ curl -X POST http://localhost:3000/api
# The server console will show:
# POST /api 200 0.456 ms - 12
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p><code>morgan</code> gives you immediate visibility into your server's traffic. <code>helmet</code> is a one-line security win that hardens your application against a whole class of attacks. Using them is standard practice for any production-grade Express server.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>What other formats does <code>morgan</code> have? ('common', 'combined', 'short', 'tiny').</li>
            <li>What specific headers does <code>helmet</code> set? (e.g., <code>Strict-Transport-Security</code>, <code>X-Frame-Options</code> to prevent clickjacking).</li>
            <li>What is <code>cors</code>? (Another essential third-party middleware for enabling Cross-Origin Resource Sharing).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://github.com/expressjs/morgan" target="_blank" class="hover:underline">morgan NPM Package</a></li>
            <li><a href="https://helmetjs.github.io/" target="_blank" class="hover:underline">helmet Official Docs</a></li>
            <li><a href="https://github.com/expressjs/cors" target="_blank" class="hover:underline">cors NPM Package</a></li>
          </ul>
        </section>
      </div>
    `
  },
  //made by achu
  //fs module

  {
    title: "File Uploads (with Multer)",
    difficulty: "Advanced",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "For file uploads, I don't parse 'multipart/form-data' myself. I use 'multer', the standard Express middleware, to handle it. I know how to configure 'multer' for a single file ('upload.single()') or multiple files, and how to access the file data from 'req.file' or 'req.files'."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>File uploads are sent from a client (like a browser) using a special <code>Content-Type</code> called <code>multipart/form-data</code>. This format is complex to parse manually.</p>
          <p class="mt-2"><strong>Multer</strong> is the standard, must-have middleware for Express to handle these uploads. It parses the incoming form, saves any files to a destination (like an <code>./uploads/</code> folder), and attaches information about the files to the <code>req</code> object (as <code>req.file</code> or <code>req.files</code>).</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (Using 'multer' for a single file)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
// --- server.js ---
// 1. Install: npm install express multer
const express = require('express');
const multer = require('multer');
const path = require('path');
const app = express();

// 2. Configure Multer's storage
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, 'uploads/'); // Save files to 'uploads/' directory
  },
  filename: (req, file, cb) => {
    // Save file with a unique name (timestamp + original name)
    cb(null, Date.now() + '-' + file.originalname);
  }
});

// 3. Initialize Multer
const upload = multer({ storage: storage });

// 4. Create an 'uploads' directory if it doesn't exist
const fs = require('fs');
if (!fs.existsSync('uploads')) {
  fs.mkdirSync('uploads');
}

// 5. Create a route that uses the middleware
// 'avatar' is the 'name' attribute of the <input type="file" name="avatar">
app.post('/profile-upload', upload.single('avatar'), (req, res) => {
  // 'req.file' is the 'avatar' file
  // 'req.body' will hold the text fields, if any
  
  if (!req.file) {
    return res.status(400).send('No file uploaded.');
  }

  console.log('File details:', req.file);
  res.json({
    message: 'File uploaded successfully!',
    filename: req.file.filename,
    path: req.file.path
  });
});

app.listen(3000, () => console.log('Server listening on port 3000...'));

// --- public/index.html (Example client form) ---
// &lt;form action="/profile-upload" method="POST" enctype="multipart/form-data"&gt;
//   &lt;h2&gt;Upload Profile Picture&lt;/h2&gt;
//   &lt;input type="file" name="avatar" /&gt;
//   &lt;button type="submit"&gt;Upload&lt;/button&gt;
// &lt;/form&gt;
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>Handling file uploads is a core requirement for almost any modern application (profile pictures, document sharing, etc.). Using <code>multer</code> correctly is a non-negotiable skill for an Express developer. It handles parsing, streaming, and saving files, which is extremely difficult to do from scratch.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>How would you handle multiple files? (<code>upload.array('photos', 10)</code>).</li>
            <li>How can you restrict file types? (Using the <code>fileFilter</code> option in <code>multer({ ... })</code>).</li>
            <li>Where is the file data in <code>req.file</code>? (<code>req.file</code> is an object with info like <code>filename</code>, <code>path</code>, <code>mimetype</code>, and <code>size</code>).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://github.com/expressjs/multer" target="_blank" class="hover:underline">Multer NPM (Official Docs)</a></li>
            <li><a href="https://www.digitalocean.com/community/tutorials/how-to-handle-file-uploads-in-express-using-multer" target="_blank" class="hover:underline">How To Handle File Uploads in Express (DigitalOcean)</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "Read File and Write file",
    difficulty: "Intermediate",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I know the 'fs' module is for file system operations. I use the async methods 'fs.readFile' and 'fs.writeFile' with an error-first callback, as they are non-blocking. I only use the sync versions, 'readFileSync' and 'writeFileSync', at the start of a script for loading config."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>The <code>fs</code> (File System) module is a core Node.js module for interacting with the file system.</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong><code>fs.readFile(path, [options], callback)</code>:</strong>
              <ul>
                <li><strong>Asynchronous.</strong> Reads the *entire* file into memory and passes its contents (as a Buffer or string) to the callback.</li>
                <li>The callback is an "error-first" callback: <code>(err, data) => { ... }</code>.</li>
              </ul>
            </li>
            <li><strong><code>fs.writeFile(path, data, [options], callback)</code>:</strong>
              <ul>
                <li><strong>Asynchronous.</strong> Writes <code>data</code> to a file, replacing it if it exists.</li>
                <li>The callback is <code>(err) => { ... }</code>.</li>
              </ul>
            </li>
            <li><strong><code>...Sync()</code> versions:</strong> <code>fs.readFileSync()</code> and <code>fs.writeFileSync()</code> are the synchronous, blocking versions. They are fine for simple scripts but should be avoided inside a web server as they block the event loop.</li>
          </ul>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (Async Read/Write)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
const fs = require('fs');
const path = require('path');

const filePath = path.join(__dirname, 'greetings.txt');
const newFilePath = path.join(__dirname, 'new-file.txt');

// 1. Asynchronous Write
fs.writeFile(filePath, 'Hello from Node.js!', 'utf8', (err) => {
  if (err) {
    return console.error('Error writing file:', err.message);
  }
  console.log('File written successfully.');

  // 2. Asynchronous Read (chained after write)
  // 'utf8' encoding returns a string, otherwise it's a Buffer
  fs.readFile(filePath, 'utf8', (err, data) => {
    if (err) {
      return console.error('Error reading file:', err.message);
    }
    console.log('File content:', data); // "Hello from Node.js!"

    // 3. Example of Sync Read (Used for initial config)
    // This blocks, but it's okay here at the top level
    try {
      const config = fs.readFileSync('package.json', 'utf8');
      console.log('Loaded config file.');
    } catch (err) {
      console.error('Could not load config', err.message);
    }
  });
});

console.log('Writing file...'); // This logs *before* "File written successfully."
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>This is a fundamental I/O operation. Understanding the async vs. sync versions is critical. Using <code>readFileSync</code> inside an Express route is a major performance bottleneck, as it will block your entire server from handling other requests until the file is read.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>What happens if you don't specify 'utf8' when reading? (You get a Buffer).</li>
            <li>What's the difference between <code>writeFile</code> and <code>appendFile</code>? (<code>writeFile</code> overwrites the file, <code>appendFile</code> adds to the end).</li>
            <li>What if the file is 10GB? (Don't use <code>readFile</code>! Use <code>fs.createReadStream</code> to stream it).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://nodejs.org/api/fs.html#fsreadfilepath-options-callback" target="_blank" class="hover:underline">Node.js Docs: fs.readFile()</a></li>
            <li><a href="https://nodejs.org/api/fs.html#fswritefilepath-data-options-callback" target="_blank" class="hover:underline">Node.js Docs: fs.writeFile()</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "File System Operations: `stat`, `unlink`, `existsSync`",
    difficulty: "Intermediate",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I use 'fs.stat' to get file metadata, like 'stats.isDirectory()' or 'stats.size'. I use 'fs.unlink' to delete a file, and 'fs.existsSync' for a simple, synchronous check to see if a file or directory exists before I try to operate on it."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>These are common "utility" functions in the <code>fs</code> module.</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong><code>fs.stat(path, callback)</code>:</strong>
              <ul>
                <li><strong>Asynchronous.</strong> Gets "stats" (metadata) about a file or directory.</li>
                <li>The callback <code>(err, stats)</code> gives you a <code>stats</code> object. You can check <code>stats.isFile()</code>, <code>stats.isDirectory()</code>, <code>stats.size</code> (in bytes), <code>stats.mtime</code> (last modified time), etc.</li>
              </ul>
            </li>
            <li><strong><code>fs.unlink(path, callback)</code>:</strong>
              <ul>
                <li><strong>Asynchronous.</strong> Deletes a file. The name "unlink" comes from Unix.</li>
                <li>The callback is <code>(err) => { ... }</code>.</li>
              </ul>
            </li>
            <li><strong><code>fs.existsSync(path)</code>:</strong>
              <ul>
                <li><strong>Synchronous.</strong> Returns <code>true</code> or <code>false</code> if the path exists.</li>
                <li>This is one of the few <code>Sync</code> methods that is acceptable to use in server code, because it's fast and often needed right before an async operation (e.g., "check if <code>uploads</code> folder exists before making it").</li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (Check, Stat, and Unlink)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
const fs = require('fs');
const path = require('path');

const tempFilePath = path.join(__dirname, 'temp-file.txt');

// 1. Check if a file exists (SYNC)
if (fs.existsSync(tempFilePath)) {
  console.log('File already exists. Deleting it...');
  
  // 2. Delete the file (ASYNC)
  fs.unlink(tempFilePath, (err) => {
    if (err) return console.error('Could not delete file:', err.message);
    console.log('File deleted.');
    createAndStatFile();
  });
} else {
  createAndStatFile();
}

function createAndStatFile() {
  fs.writeFile(tempFilePath, 'This is temporary', (err) => {
    if (err) return console.error('Write failed:', err.message);
    
    // 3. Get metadata for the file (ASYNC)
    fs.stat(tempFilePath, (err, stats) => {
      if (err) return console.error('Stat failed:', err.message);
      
      console.log('--- File Stats ---');
      console.log('Is it a file?', stats.isFile()); // true
      console.log('Is it a directory?', stats.isDirectory()); // false
      console.log('File size (bytes):', stats.size);
      console.log('Last modified:', stats.mtime);
    });
  });
}
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>These are the building blocks of file management. You need <code>stat</code> to check permissions or file types, <code>unlink</code> to clean up temporary files (like after a file upload), and <code>existsSync</code> for safe, defensive checks before creating directories or writing files.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>How would you delete a directory? (<code>fs.rmdir()</code> for empty ones, or <code>fs.rm(path, { recursive: true })</code> for non-empty).</li>
            <li>What's the difference between <code>fs.stat</code> and <code>fs.lstat</code>? (<code>stat</code> follows symbolic links, <code>lstat</code> gives stats about the link itself).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://nodejs.org/api/fs.html#fsstatpath-options-callback" target="_blank" class="hover:underline">Node.js Docs: fs.stat()</a></li>
            <li><a href="https://nodejs.org/api/fs.html#fsunlinkpath-callback" target="_blank" class="hover:underline">Node.js Docs: fs.unlink()</a></li>
            <li><a href="https://nodejs.org/api/fs.html#fsexistssyncpath" target="_blank" class="hover:underline">Node.js Docs: fs.existsSync()</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "Create or Remove Directory",
    difficulty: "Intermediate",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I use 'fs.mkdir()' to create a directory. If I need to create nested directories, like 'a/b/c', I use the '{ recursive: true }' option. To remove a directory, I use 'fs.rmdir()' for empty ones, or 'fs.rm()' with '{ recursive: true }' for non-empty ones."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>The <code>fs</code> module provides methods for managing directories (folders).</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><strong><code>fs.mkdir(path, [options], callback)</code>:</strong>
              <ul>
                <li><strong>Asynchronous.</strong> Creates a new directory.</li>
                <li><strong>Options:</strong> <code>{ recursive: true }</code> is essential. It will create parent directories as needed (like <code>mkdir -p</code> in bash) and won't throw an error if the directory already exists.</li>
              </ul>
            </li>
            <li><strong><code>fs.rmdir(path, [options], callback)</code>:</strong>
              <ul>
                <li><strong>Asynchronous.</strong> Removes a directory. This will fail if the directory is not empty.</li>
              </ul>
            </li>
            <li><strong><code>fs.rm(path, [options], callback)</code>:</strong> (Modern)
              <ul>
                <li><strong>Asynchronous.</strong> The "new" way to remove files or directories.</li>
                <li>To remove a non-empty directory, use: <code>fs.rm(path, { recursive: true, force: true }, cb)</code>.</li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (Recursive Create and Remove)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
const fs = require('fs');
const path = require('path');

// This path is nested: 'data' contains 'logs'
const nestedDir = path.join(__dirname, 'data', 'logs');

// 1. Create a nested directory (ASYNC)
fs.mkdir(nestedDir, { recursive: true }, (err) => {
  if (err) return console.error('Could not create dir:', err.message);
  
  console.log('Directory created:', nestedDir);

  // 2. Write a file inside it
  const logFile = path.join(nestedDir, 'app.log');
  fs.writeFile(logFile, 'Log entry', (err) => {
    if (err) return console.error('Could not write log:', err.message);

    console.log('Log file created.');

    // 3. Remove the non-empty parent directory (ASYNC)
    const dirToRemove = path.join(__dirname, 'data');
    fs.rm(dirToRemove, { recursive: true, force: true }, (err) => {
      if (err) return console.error('Could not remove dir:', err.message);
      
      console.log('Recursively removed:', dirToRemove);
    });
  });
});
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>This is essential for setup and cleanup. You use <code>mkdir</code> to ensure your <code>uploads</code> or <code>logs</code> directories exist when your server starts. You use <code>rm</code> or <code>rmdir</code> to clean up temporary directories or user data upon deletion.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>How would you read the contents of a directory? (<code>fs.readdir(path, callback)</code>, which gives you an array of filenames).</li>
            <li>What's the difference between <code>fs.rmdir</code> and <code>fs.rm</code>? (<code>rmdir</code> is older and only works on empty directories. <code>rm</code> is newer, more powerful, and can remove files or non-empty directories with the <code>recursive</code> flag).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://nodejs.org/api/fs.html#fsmkdirpath-options-callback" target="_blank" class="hover:underline">Node.js Docs: fs.mkdir()</a></li>
            <li><a href="https://nodejs.org/api/fs.html#fsrmpath-options-callback" target="_blank" class="hover:underline">Node.js Docs: fs.rm()</a></li>
          </ul>
        </section>
      </div>
    `
  },
  {
    title: "File Permissions",
    difficulty: "Advanced",
    details: `
      <blockquote class="italic text-gray-400 border-l-4 border-blue-500 pl-4 mb-4">
        Tell the reviewer: "I know file permissions are handled by the OS and are based on 'read', 'write', and 'execute' for the 'user', 'group', and 'other'. I can check permissions using 'fs.stat()' to get the 'mode' (like 0o755), and I can change them using 'fs.chmod()'."
      </blockquote>

      <div class="space-y-6 text-gray-300">
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Short explanation</h2>
          <p>File Permissions control who can read, write, or execute a file. This is a core concept of Linux/macOS/Unix operating systems, which Node.js runs on.</p>
          <p class="mt-2">Permissions are represented by an <strong>octal (base-8) number</strong>, like <code>0o755</code>.</p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li>The number is made of 3 digits: (Owner)(Group)(Others)</li>
            <li>Each digit is a sum of permissions:
              <ul>
                <li><strong>4</strong> = Read</li>
                <li><strong>2</strong> = Write</li>
                <li><strong>1</strong> = Execute</li>
              </ul>
            </li>
          </ul>
          <p class="mt-2"><strong>Common Modes:</strong></p>
          <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
            <li><code>0o755</code> (rwx r-x r-x): Owner can do anything (4+2+1=7). Group/Others can read/execute (4+1=5). (Common for directories).</li>
            <li><code>0o644</code> (rw- r-- r--): Owner can read/write (4+2=6). Group/Others can only read (4). (Common for files).</li>
          </ul>
          <p class="mt-2">In Node.js, you use <code>fs.stat</code> to read the mode, and <code>fs.chmod</code> to change it.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Example (Check and Set Permissions)</h2>
          <div class="bg-gray-900 p-4 rounded-xl border border-gray-700">
            <pre class="bg-gray-800 text-sm p-3 rounded text-white overflow-x-auto"><code class="language-javascript">
const fs = require('fs');
const path = require('path');

const scriptFile = path.join(__dirname, 'my-script.sh');

// Create a dummy script file
fs.writeFile(scriptFile, '#!/bin/bash\necho "Hello"', (err) => {
  if (err) return console.error(err);
  console.log('Script created.');

  // 1. Check current permissions
  fs.stat(scriptFile, (err, stats) => {
    if (err) return console.error(err);
    // .toString(8) converts the mode number to an octal string
    console.log('Original mode:', (stats.mode & 0o777).toString(8)); // e.g., "644"

    // 2. Make the file executable for the owner
    // We want 744 (rwx r-- r--)
    fs.chmod(scriptFile, 0o744, (err) => {
      if (err) return console.error('chmod failed:', err.message);
      
      console.log('Mode changed to 744.');

      // 3. Verify the new permissions
      fs.stat(scriptFile, (err, newStats) => {
        console.log('New mode:', (newStats.mode & 0o777).toString(8)); // "744"
      });
    });
  });
});
            </code></pre>
          </div>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Why it matters</h2>
          <p>Permissions are critical for security and operations. If your Node.js app generates a script, it must use <code>fs.chmod</code> to make it executable. If it creates a user's data file, it should set permissions (e.g., <code>0o600</code>, "read/write for owner only") to prevent other users on the system from reading it.</p>
        </section>

        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Related questions the reviewer may ask</h2>
          <ul class="list-disc list-inside ml-4">
            <li>What is <code>(stats.mode & 0o777)</code> doing? (The full <code>mode</code> contains extra data. Bitwise-ANDing with <code>0o777</code> isolates *only* the permission bits).</li>
            <li>How do you change file ownership? (<code>fs.chown()</code>).</li>
            <li>How does this apply to Windows? (It doesn't, really. Windows has a different, more complex ACL system. Node's <code>fs.chmod</code> has limited effect on Windows).</li>
          </ul>
        </section>
        
        <section>
          <h2 class="text-lg font-semibold text-white mb-2">Further Reading</h2>
          <ul class="list-disc list-inside ml-4 text-blue-400">
            <li><a href="https://nodejs.org/api/fs.html#fschmodpath-mode-callback" target="_blank" class="hover:underline">Node.js Docs: fs.chmod()</a></li>
            <li><a href="https://nodejs.org/api/fs.html#statsmode" target="_blank" class="hover:underline">Node.js Docs: stats.mode</a></li>
            <li><a href="https://www.linux.com/tutorials/understanding-linux-file-permissions/" target="_blank" class="hover:underline">Understanding Linux File Permissions</a></li>
          </ul>
        </section>
      </div>
    `
  }

  //topics created by achu ends here,
  //creating commit feat(content): add fs and fs modules
]


    window.practicals = [


    ];

    window.proTips = [


    ];



  </script>
  <script src="sidebar.js"></script>
  <script src="main.js"></script>
</body>

</html>